# 算法提高笔记





## 数字三角模型



### 方格取数
设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：
![](D:/TyporaPhotoCache/19_764ece6ed5-2-16347998093303.gif)
某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。
在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0)。
此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

输入格式
第一行为一个整数N，表示 N×N 的方格图。
接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。
行和列编号从 $1$ 开始。
一行"0 0 0"表示结束。

输出格式
输出一个整数，表示两条路径上取得的最大的和。

数据范围
$N \leq 10$

> 运用dp。主要问题是如何避免出现同个点重复取值。dp三个状态dp\[k]\[i]\[j]，k表示两个路径分别的总步数，i，j分别表示两个路径横（或者纵）向所走的步数。例如dp\[5]\[2]\[4]可理解为两条路径分别到了(2,5-2)，（4,5-4）的点。然后对三个状态从小到大dp在减去重复数即可
>
> 原理：对k从小到大遍历时保证了当前要更新的点不会出现在之前某次更新中，即避免了一条路径上当前点是另一条路径之前的点，然后在判断该点是否是此时两路径共有点就不会出现重复情况

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=15;
using namespace std;

ll gra[maxn][maxn];
ll dp[maxn<<1][maxn][maxn];


int main(){
ll i,j;
ll n;
ll a,b,c;

cin>>n;

while(~scanf("%lld%lld%lld",&a,&b,&c)&&(a+b+c))
    gra[a][b]=c;


for(ll k=2;k<=2*n;k++)  // 从2开始就代表从(1,1)点开始
{
    for(i=1;i<=k;i++)  // 注意避免越界
    for(j=1;j<=k;j++)
    {
        ll w=gra[i][k-i]+(i==j?0:gra[j][k-j]);  // 重复点即i==j时
        ll res=0;
        res=max(res,dp[k-1][i-1][j]);
        res=max(res,dp[k-1][i][j-1]);
        res=max(res,dp[k-1][i][j]);
        res=max(res,dp[k-1][i-1][j-1]);
        dp[k][i][j]=res+w;
    }
}
printf("%lld\n",dp[n<<1][n][n]);
}

```



### 传纸条

### 传纸条
小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。
一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。
幸运的是，他们可以通过传纸条来进行交流。
纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。
从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。
在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。
班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。
还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可 以用一个 $0 \sim 100$ 的自然数来表示，数越大表示越好心。
小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。
现在，请你帮助小渊和小轩找到这样的两条路径。

输入格式
第一行有 $2$ 个用空格隔开的整数 $m$ 和 $n$，表示学生矩阵有 $m$ 行 $n$ 列。
接下来的 $m$ 行是一个 $m \times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度，每行的 $n$ 个整数之间用空格隔开。

输出格式
输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

数据范围
$1 \leq n,m \leq 50$

> 题意：两条左上角点到右下角点的路径，不能相交，求最大经过点价值和
>
> 思路：这题可以直接用方格取数的模板来解。方格取数是相交时不重复加价值，如果出现两路径是有重叠的，那么我们一定可以从中选一条路径，再找另一条路径使其值大于等于原来之和。
>
> 原理：假如两条路径有相交点。那么一定可以选取该点的右上或者左下点作为其中一条路径的新点来避免两路径相交。
>
> 其实我们也可以理解为方格取数一定能选出两条不相交路径价值和
>
> 注意这里是行数列数不相同，依据对k的定义处理即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=5e1+5;
const ll inf=1e12;
using namespace std;

ll n,m;
ll gra[maxn][maxn];
ll dp[maxn<<1][maxn][maxn];

int main(){
ll i,j,k;

cin>>n>>m;

for(i=1;i<=n;i++)
for(j=1;j<=m;j++)
    scanf("%lld",&gra[i][j]);


for(k=2;k<=n+m;k++)
{
    for(i=1;i<=min(k-1,n);i++)
    for(j=1;j<=min(k-1,n);j++)
    {
        ll w=gra[i][k-i]+(i!=j?gra[j][k-j]:0);

        ll res=dp[k][i][j];
        res=max(res,dp[k-1][i-1][j]);
        res=max(res,dp[k-1][i][j-1]);
        res=max(res,dp[k-1][i-1][j-1]);
        res=max(res,dp[k-1][i][j]);
        dp[k][i][j]=res+w;
    }
    
}
printf("%lld\n",dp[n+m][n][n]);
}
```







## 最长上升子序列



### 最长上升下降子序列

> 题意：求最长上升子序列和最长下降子序列的最大值
>
> 求最长上升子序列用贪心思路，每次当不可以放入该值找到原序列中第一个大于等于（看情况，该题是上升，不是非下降，否则找大于）的数，并更换它。贪心理解为不改变原序列大小的情况下使以后插入的数不用那么大。也可理解为实则新开了一个序列，该序列结尾为更新值
>
> 最长下降子序列则建议从后往前遍历。因为用可以直接用lower_bound

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e5+5;
using namespace std;

vector<ll> ve;
ll num[maxn];
ll ans;

int main(){
ll i,j;
ll T;
ll n;
ll x;
cin>>T;
ll p;
while(T--)
{
    ans=0;
    
    cin>>n;
    
    for(i=1;i<=n;i++)
        scanf("%lld",&num[i]);
    
    ve.clear();
    for(i=1;i<=n;i++)
    {
        x=num[i];
        if(ve.empty()||ve.back()<x)
            ve.push_back(x);
        else
        {
            p=lower_bound(ve.begin(),ve.end(),x)-ve.begin();
            ve[p]=x;
        }
    }
    ans=max(ans,(ll)ve.size());
    
    ve.clear();
    for(i=n;i>=1;i--)
    {
        x=num[i];
        if(ve.empty()||ve.back()<x)
            ve.push_back(x);
        else
        {
            p=lower_bound(ve.begin(),ve.end(),x)-ve.begin();
            ve[p]=x;
        }
    }
    ans=max(ans,(ll)ve.size());    
    
    printf("%lld\n",ans);
}

}
```



### 登山

五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。
同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。
队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？

输入格式
第一行包含整数N，表示景点数量。
第二行包含N个整数，表示每个景点的海拔。

输出格式
输出一个整数，表示最多能浏览的景点数。

数据范围
$2 \leq N \leq 1000$

> 题意：先向上后向下（类似登山下山），且不选连续相同值，问最长子序列大小



#### 答案做法

> O(n<sup>2</sup>)复杂度，运用dp思想，两层循环，第一层循环遍历所有数，第二层循环找前面的数，比他大的则更新dp[0]（当前一直上升的状态），比他小则更新dp[1]（已有上升和下降的状态）。
>
> 更新dp[1]，可以用对应数的dp[0]和dp[1]来更新。更新dp[0]的话则只能用对应数的dp[0]

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
using namespace std;

ll dp[maxn][5];
ll a[maxn];
ll n;

int main(){
ll i,j;
cin>>n;

for(i=1;i<=n;i++)
    scanf("%lld",&a[i]);

for(i=1;i<=n;i++)
{
    dp[i][0]=1;dp[i][1]=1;
    for(j=1;j<i;j++)
    {
        if(a[i]>a[j])
            dp[i][0]=max(dp[i][0],dp[j][0]+1);
        else if(a[i]<a[j])  // 注意==时候不更新
            dp[i][1]=max(dp[i][1],max(dp[j][0]+1,dp[j][1]+1));  
    }
}

ll ans=0;

for(i=1;i<=n;i++)
    ans=max(ans,max(dp[i][0],dp[i][1]));

printf("%lld\n",ans);
}
```



#### 自己做法

> O(nlogn)复杂度，先正序和逆序遍历分别得到每个点的前面的最长上升子序列和后面的最长下降子序列。然后去重即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
using namespace std;

vector<ll> ve;
ll num[maxn];
ll up[maxn];    ll usedup[maxn];
ll down[maxn];  ll useddown[maxn];

int main(){
ll i,j;
ll n;
ll p;
cin>>n;

for(i=1;i<=n;i++)
    scanf("%lld",&num[i]);

ll ans=0;

for(i=1;i<=n;i++)
{
    ll x=num[i];
    bool flag=0;
    if(ve.empty()||ve.back()<x)
        ve.push_back(x);
    else
    {
        p=lower_bound(ve.begin(),ve.end(),x)-ve.begin();
        ve[p]=x;
    }
    up[i]=ve.size();usedup[i]=ve.back();
}
ve.clear();
for(i=n;i>=1;i--)
{
    ll x=num[i];
    bool flag=0;
    if(ve.empty()||ve.back()<x)
        ve.push_back(x);
    else
    {
        p=lower_bound(ve.begin(),ve.end(),x)-ve.begin();
        ve[p]=x;
    }
    down[i]=ve.size();useddown[i]=ve.back();
}

for(i=1;i<=n;i++)
{
    ll now=up[i]+down[i];
    if(usedup[i]==useddown[i])
        now--;
    ans=max(ans,now);
}

printf("%lld\n",ans);
}
```





### 最长上升子序列和



#### 一般做法

> 遍历前面比自己小的数来更新以自己为终止位的结果

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
using namespace std;

ll a[maxn];
ll dp[maxn];
ll n;
ll ans;

int main(){
ll i,j;

cin>>n;
for(i=1;i<=n;i++)
    scanf("%lld",&a[i]);

for(i=1;i<=n;i++)
{
    dp[i]=a[i];
    for(j=1;j<i;j++)
    {
        if(a[i]>a[j])
            dp[i]=max(dp[i],dp[j]+a[i]);
    }
    ans=max(ans,dp[i]);
}

printf("%lld\n",ans);

}
```



#### 树状数组优化

> 用树状数组可以维护每个值的最大结果
>
> 用vector离散化获得每个数对应大小下标，然后遍历时维护对应下标的结果即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
using namespace std;


ll tree[maxn];
ll a[maxn];
vector<ll> ve;


ll lowbit(ll x)
{
    return x&(-x);
}

void Inserts(ll p,ll x)
{
    for(ll i=p;i<maxn;i+=lowbit(i))
        tree[i]=max(tree[i],x);
}

ll Finds(ll p)
{
    ll res=0;
    for(ll i=p;i>0;i-=lowbit(i))
        res=max(res,tree[i]);
    return res;
}


ll GetId(ll x)
{
    return lower_bound(ve.begin(),ve.end(),x)-ve.begin()+1;
}

int main(){
ll i,j;    

ll n;
cin>>n;

for(i=1;i<=n;i++)
{
    scanf("%lld",&a[i]);
    ve.push_back(a[i]);
}

sort(ve.begin(),ve.end());
ve.erase(unique(ve.begin(),ve.end()),ve.end());

ll ans=0;
ll now;
for(i=1;i<=n;i++)
{
    ans=max(ans,now=Finds(GetId(a[i])-1)+a[i]);
    Inserts(GetId(a[i]),now);
}
printf("%lld\n",ans);

}
```



### 导弹防御系统
为了对抗附近恶意国家的威胁，$R$ 国更新了他们的导弹防御系统。
一套防御系统的导弹拦截高度要么一直 <strong>严格单调</strong> 上升要么一直 <strong>严格单调</strong> 下降。
例如，一套系统先后拦截了高度为 $3$ 和高度为 $4$ 的两发导弹，那么接下来该系统就只能拦截高度大于 $4$ 的导弹。
给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。

输入格式
输入包含多组测试用例。
对于每个测试用例，第一行包含整数 $n$，表示来袭导弹数量。
第二行包含 $n$ 个<strong>不同的</strong>整数，表示每个导弹的高度。
当输入测试用例 $n=0$ 时，表示输入终止，且该用例无需处理。

输出格式
对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。

数据范围
$1 \leq n \leq 50$

> 严格单调即指不会出现等于的情况，这题用暴力的思路，分别维护一个单调下降数组（导弹严格单调上升）以及单调上升数组，dfs即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=5e1+5;
using namespace std;

ll num[maxn];
ll up[maxn];
ll down[maxn];
ll n;

ll ans=maxn;

ll Lower(ll l,ll r,ll x)
{
    while(l+1<r)
    {
        ll mid=(l+r)>>1;
        if(down[mid]<x)
            l=mid;
        else
            r=mid;
    }
    return r;
}

ll Upper(ll l,ll r,ll x)
{
    while(l+1<r)
    {
        ll mid=(l+r)>>1;
        if(up[mid]>x)
            l=mid;
        else
            r=mid;
    }
    return r;
}

void dfs(ll nup,ll ndown,ll pc)
{
    if(nup+ndown>=ans)
        return;
    if(pc==n+1)
    {
        ans=min(ans,nup+ndown);
        return;
    }
    ll x=num[pc];
    ll temp=-1; ll p;
    if(nup==0||up[nup]>=x)
        up[++nup]=x;
    else
    {
        p=Upper(0,nup+1,x);
        temp=up[p];
        up[p]=x;
    }
    dfs(nup,ndown,pc+1);
    
    if(temp==-1)
        nup--;
    else
        up[p]=temp;
    
    temp=-1;
    if(ndown==0||down[ndown]<=x)
        down[++ndown]=x;
    else
    {
        p=Lower(0,ndown+1,x);
        temp=down[p];
        down[p]=x;
    }
    dfs(nup,ndown,pc+1);
    
    if(temp==-1)
        ndown--;
    else
        down[p]=temp;    
    
}

int main(){
ll i,j;

while(~scanf("%lld",&n)&&n)
{
    for(i=1;i<=n;i++)
        scanf("%lld",&num[i]);
    ans=maxn;
    dfs(0,0,1);
    
    printf("%lld\n",ans);
}

}
```



### 最长公共上升子序列
小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。
小沐沐说，对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的 公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。
奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。
不过，只要告诉奶牛它的长度就可以了。
数列 $A$ 和 $B$ 的长度均不超过 $3000$。
输入格式
第一行包含一个整数 $N$，表示数列 $A，B$ 的长度。
第二行包含 $N$ 个整数，表示数列 $A$。
第三行包含 $N$ 个整数，表示数列 $B$。

输出格式
输出一个整数，表示最长公共上升子序列的长度。

数据范围
$1 \leq N \leq 3000$,序列中的数字均不超过 $2^{31}-1$。

> 定义dp为以当前b数组位置为子序列的结尾的最长长度。一般dp是三层循环，第一、二层遍历i、j，第三层遍历前面比b[j]小的数，但这里可以做一个优化。首先当a[i]=\=b[j]的时候会更新dp[j]，要查找前面等于b[j]的数，等价于查找前面等于a[i]的数，所以当前数<a[i]时维护一个值，下次再碰到a[i]==b[j]时用这个值更新即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=3e3+5;
using namespace std;

ll dp[maxn];
ll a[maxn];
ll b[maxn];
ll n;

int main(){
ll i,j;
cin>>n;

for(i=1;i<=n;i++)
    scanf("%lld",&a[i]);
for(i=1;i<=n;i++)
    scanf("%lld",&b[i]);
    
for(i=1;i<=n;i++)
{
    ll maxv=0;
    
    for(j=1;j<=n;j++)
    {
        if(b[j]==a[i])
            dp[j]=max(dp[j],maxv+1);
        else if(b[j]<a[i])
            maxv=max(maxv,dp[j]);
    }
}

ll ans=0;

for(i=1;i<=n;i++)
    ans=max(ans,dp[i]);
    
printf("%lld\n",ans);
    
}
```





## 背包模型



### 不到0的背包

对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。

当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服。

当小智的精灵球用完时，狩猎也宣告结束。

我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。

如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。

小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。

现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。

请问，小智该如何选择收服哪些小精灵以达到他的目标呢？

**输入格式**

输入数据的第一行包含三个整数：N，M，K，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。

之后的K行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。

**输出格式**

输出为一行，包含两个整数：C，R，分别表示最多收服C个小精灵，以及收服C个小精灵时皮卡丘的剩余体力值最多为R。

> 该题主要要注意的是体力不能减到0，我们可以转换成体力由m变为m-1，再进行背包处理即可，最后求剩余体力值把m+1 即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
const ll maxm=5e2+5;
using namespace std;

ll n,m;ll ns;
ll dp[maxn][maxm];
ll a[maxn];ll b[maxn];

int main(){
ll i,j,k;

cin>>n>>m>>ns;
m--;
for(i=1;i<=ns;i++)
    scanf("%lld%lld",&a[i],&b[i]);

for(i=1;i<=ns;i++)
{
    for(j=n;j>=a[i];j--)
        for(k=m;k>=b[i];k--)
            dp[j][k]=max(dp[j][k],dp[j-a[i]][k-b[i]]+1);
}
m++;
ll c=0;ll r=m;

for(i=m;i>=0;i--)
{
    if(dp[n][i]>=c)
    {
        c=dp[n][i];r=m-i;
    }
        
}
printf("%lld %lld\n",c,r);
}
```



### 货币系统

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。
为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。
在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] × t[i]$ 的和为 $x$。
然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。
例如在货币系统 $n=3, a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。
两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。
现在网友们打算简化一下货币系统。
他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。
他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。

输入格式
输入文件的第一行包含一个整数 $T$，表示数据的组数。
接下来按照如下格式分别给出 $T$ 组数据。
每组数据的第一行包含一个正整数 $n$。
接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$。

输出格式
输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。

数据范围
$1 \leq n \leq 100$,
$1 \leq a[i] \leq 25000$,
$1 \leq T \leq 20$

> 本题本质上是问你是否能用数组中某些数得到数组中另外一个数，所以用dp的思想，如果数组中该数dp后次数等于1，则要保留，否则舍弃

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=3e4+5;
using namespace std;

ll dp[maxn];
ll a[maxn];
ll n;

int main(){
ll i,j;
ll T;

cin>>T;
while(T--)
{
    memset(dp,0,sizeof(dp));
    dp[0]=1;
    cin>>n;
    ll maxv=0;    
    for(i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);  
        maxv=max(maxv,a[i]);
    }
    
    for(i=1;i<=n;i++)
    {
        for(j=a[i];j<=maxv;j++)
            dp[j]+=dp[j-a[i]];
    }
    
    ll ans=0;
    for(i=1;i<=n;i++)
    {
        if(dp[a[i]]==1)
            ans++;
    }
    
    printf("%lld\n",ans);
}
    
}
```



### 混合背包

有 $N$ 种物品和一个容量是 $V$ 的背包。

物品一共有三类：

- 第一类物品只能用1次（01背包）；
- 第二类物品可以用无限次（完全背包）；
- 第三类物品最多只能用 $s_i$ 次（多重背包）；

每种体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

第一行两个整数，$N$,$V$，用空格隔开，分别表示物品种数和背包容积。

接下来有 $N$ 行，每行三个整数 $v_i,w_i,v_i,w_i,s_i，$用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。

- $s_i=−1$ 表示第 ii 种物品只能用1次；
- $s_i=0$ 表示第 ii 种物品可以用无限次；
- $s_i>0$ 表示第 ii 种物品可以使用 $s_i$ 次；

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
using namespace std;

ll dp[5][maxn]; ll p;
ll n,V;
ll v,w,s;
ll que[maxn];

int main(){
ll i,j,k;

cin>>n>>V;

while(n--)
{
    scanf("%lld%lld%lld",&v,&w,&s);
    
    if(s==-1)
        for(i=V;i>=v;i--)
            dp[p][i]=max(dp[p][i],dp[p][i-v]+w);
    else if(s==0)
        for(i=v;i<=V;i++)
            dp[p][i]=max(dp[p][i],dp[p][i-v]+w);
    else
    {
        p^=1;
        for(i=0;i<v;i++)
        {
            ll l=0;ll r=-1;
            for(j=i;j<=V;j+=v)
            {
                dp[p][j]=max(dp[p][j],dp[p^1][j]);   
                
                if(l<=r && j-que[l]>v*s)    l++;
                if(l<=r)    dp[p][j]=max(dp[p][j],dp[p^1][que[l]]+(j-que[l])/v*w);
                while(l<=r && dp[p^1][j]-dp[p^1][que[r]]>=(j-que[r])/v*w)  r--;
                que[++r]=j;
            }
        }

    }

}
printf("%lld\n",dp[p][V]);
}
```



### 求最小需求
潜水员为了潜水要使用特殊的装备。
他有一个带2种气体的气缸：一个为氧气，一个为氮气。
让潜水员下潜的深度需要各种数量的氧和氮。
潜水员有一定数量的气缸。
每个气缸都有重量和气体容量。
潜水员为了完成他的工作需要特定数量的氧和氮。
他完成工作所需气缸的总重的最低限度的是多少？
例如：潜水员有5个气缸。每行三个数字为：氧，氮的（升）量和气缸的重量：
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119

如果潜水员需要5升的氧和60升的氮则总重最小为249（1，2或者4，5号气缸）。
你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。

输入格式
第一行有2个整数 $m，n$。它们表示氧，氮各自需要的量。
第二行为整数 $k$ 表示气缸的个数。
此后的 $k$ 行，每行包括$a_i，b_i，c_i$，3个整数。这些各自是：第 $i$ 个气缸里的氧和氮的容量及气缸重量。

输出格式
仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。

数据范围
$1 \leq m \leq 21$,
$1 \leq n \leq 79$,
$1 \leq k \leq 1000$,
$1 \leq a_i \leq 21$,
$1 \leq b_i \leq 79$,
$1 \leq c_i \leq 800$

输入样例：
5 60
5
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119

输出样例：
249

> 要注意如果 2 5更新为100，其在2 5 以内的一定要<=100。即也要被更新
>
> 所以我们可以定义状态转移为dp\[i][j]=min(dp\[i][j],dp\[max((ll)0,i-a)][max((ll)0,j-b)]+c); 然后遍历从所需值到0（包括0）的更新。包括0是因为会出现如 0 5的情况

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxm=25;
const ll maxn=85;
const ll inf=1e12;
using namespace std;

ll dp[maxm][maxn];
ll m,n;

int main(){
ll i,j;
ll a,b,c;
ll T;

for(i=0;i<maxm;i++)
for(j=0;j<maxn;j++)
    dp[i][j]=inf;
dp[0][0]=0;

cin>>m>>n;
cin>>T;

while(T--)
{
    scanf("%lld%lld%lld",&a,&b,&c);
    
    for(i=m;i>=0;i--)
    for(j=n;j>=0;j--)
    {
        dp[i][j]=min(dp[i][j],dp[max((ll)0,i-a)][max((ll)0,j-b)]+c);
    }

}

printf("%lld\n",dp[m][n]);

}
```



### 分组背包
总公司拥有M台 <strong>相同</strong> 的高效设备，准备分给下属的N个分公司。
各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。
问：如何分配这M台设备才能使国家得到的盈利最大？
求出最大盈利值。
分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数M。

输入格式
第一行有两个数，第一个数是分公司数N，第二个数是设备台数M；
接下来是一个N*M的矩阵，矩阵中的第 i 行第 j 列的整数表示第 i 个公司分配 j 台机器时的盈利。

输出格式
第一行输出最大盈利值；
接下N行，每行有2个数，即分公司编号和该分公司获得设备台数。
答案不唯一，输出任意合法方案即可。

数据范围
$1 \leq N \leq 10$,
$1 \leq M \leq 15$

输入样例：
3 3
30 40 50
20 30 50
20 25 30

输出样例：
70
1 1
2 1
3 1

> 一个公司视为一个物品组，每个物品组只能选一个物品。三层循环，第一层指某个公司，第二层遍历所有台数，第三层遍历该公司所有可行的更新台数。记录状态即对每个dp值多开一个数组，表示该dp值所用的第几个公司的设备台数

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=25;
using namespace std;

ll val[maxn][maxn];
ll st[maxn][maxn];
ll dp[maxn];
ll n,m;
ll ans=0;

int main(){
ll i,j,k;

cin>>n>>m;

for(i=1;i<=n;i++)
for(j=1;j<=m;j++)
    scanf("%lld",&val[i][j]);

for(i=1;i<=n;i++)
{
    for(j=m;j>=1;j--)
    {
        for(k=j;k>=1;k--)
        {
            if(dp[j]<dp[j-k]+val[i][k])
            {
                dp[j]=dp[j-k]+val[i][k];
                memcpy(st[j],st[j-k],sizeof(st[j-k]));st[j][i]=k;
            }
        }
    }
}

printf("%lld\n",dp[m]);

for(i=1;i<=n;i++)
    printf("%lld %lld\n",i,st[m][i]);

}
```



### 有依赖的背包问题
有 $N$ 个物品和一个容量是 $V$ 的背包。
物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。
如下图所示：
![](https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ图片20181018170337.png)
如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。
每件物品的编号是 $i$，体积是 $v_i$，价值是 $w_i$，依赖的父节点编号是 $p_i$。物品的下标范围是 $1 \cdots N$。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行有两个整数 $N，V$，用空格隔开，分别表示物品个数和背包容量。
接下来有 $N$ 行数据，每行数据表示一个物品。
第 $i$ 行有三个整数 $v_i, w_i, p_i$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。
如果 $p_i = -1$，表示根节点。 <strong>数据保证所有物品构成一棵树。</strong>

输出格式
输出一个整数，表示最大价值。

数据范围
$1 \leq N, V \leq 100$
$1 \leq v_i, w_i\le 100$
父节点编号范围：

* 内部结点：$1 \leq p_i \leq N$;
* 根节点 $p_i = -1$;

>  用dfs和分组背包的思维，设每个点的dp状态为以该节点为根节点的1\~V的最大总价值，更新的时候先更新每个点所有子节点，用子节点的dp更新该点的dp，由于一定要有该节点才有子节点的dp，所以从后往前更新放入该子节点物品后的dp。可以理解为先更新含有子节点的0\~V-v[x]的dp，然后放入V\[x]把0\~V-v[x]推到V[x]\~V

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e2+5;
using namespace std;

ll dp[maxn][maxn];
ll v[maxn];ll w[maxn];
ll h[maxn];ll ne[maxn];ll e[maxn];ll idx;
ll n,V;
ll rt;
void add(ll a,ll b)
{
    idx++;
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx;
}

void dfs(ll u)
{
    ll i,j;
    ll son;
    
    for(i=h[u];i!=0;i=ne[i])
    {
        son=e[i];
        dfs(son);
        
        for(j=V-v[u];j>=0;j--)
        for(ll k=0;k<=j;k++)
            dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[son][k]);
    }

    for(i=V;i>=v[u];i--)
        dp[u][i]=dp[u][i-v[u]]+w[u];   

    for(i=0;i<v[u];i++)
        dp[u][i]=0;
}

int main(){
ll i,j;
ll x;
cin>>n>>V;

for(i=1;i<=n;i++)
{
    scanf("%lld%lld%lld",&v[i],&w[i],&x);
    if(x==-1)
        rt=i;
    else
        add(x,i);
}

dfs(rt);

cout<<dp[rt][V]<<endl;
    
}
```



### 背包求方案数
有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。
第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出 <strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9 + 7$ 的结果。

输入格式
第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。
接下来有 $N$ 行，每行两个整数 $v_i, w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。

输出格式
输出一个整数，表示 <strong>方案数</strong> 模 $10^9 + 7$ 的结果。

数据范围
$0 \lt N, V \leq 1000$
$0\lt v_i, w_i \leq 1000$

> 运用dp思路更新最优结果，再开一个数组保存当前dp对应的方案数
>
> 注意开始时方案数都要初始化为1。因为无论如何都会有1中方案数，即使结果为0

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
const ll mod=1e9+7;
using namespace std;

ll v,w;
ll n,V;
ll dp[maxn];
ll amo[maxn];

int main(){
ll i,j;

cin>>n>>V;

for(i=0;i<=V;i++)
    amo[i]=1;

for(i=1;i<=n;i++)
{
    scanf("%lld%lld",&v,&w);
    
    for(j=V;j>=v;j--)
    {
        if(dp[j]==dp[j-v]+w)
        {
            amo[j]+=amo[j-v];
            amo[j]%=mod;
        }
        else if(dp[j]<dp[j-v]+w)
        {
            dp[j]=dp[j-v]+w;
            amo[j]=amo[j-v];
        }
    }
}
printf("%lld\n",amo[V]);
}
```



### 背包求具体方案
有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。
第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出 <strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1 \cdots N$。

输入格式
第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。
接下来有 $N$ 行，每行两个整数 $v_i, w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。

输出格式
输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。
物品编号范围是 $1 \cdots N$。

数据范围
$0 \lt N, V \leq 1000$
$0\lt v_i, w_i \leq 1000$

> 定义dp\[i]\[j]代表第i个物品时不超过j体积的最大价值。从下往上更新，再从dp\[1]\[V]找路径即可。当碰到可选不必选时，优先选可选。

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
using namespace std;

ll dp[maxn][maxn];
ll v[maxn];ll w[maxn];
ll n,V;

int main(){
ll i,j,k;

cin>>n>>V;

for(i=1;i<=n;i++)
    scanf("%lld%lld",&v[i],&w[i]);

for(i=n;i>=1;i--)
{
    for(j=0;j<=V;j++)
    {
        dp[i][j]=dp[i+1][j];
        if(j>=v[i])
            dp[i][j]=max(dp[i][j], dp[i+1][j-v[i]]+w[i]);
    }
}

vector<ll> ve;
for(i=1,j=V;i<=n;i++)
{
    if(j>=v[i]&&dp[i][j]==dp[i+1][j-v[i]]+w[i])  // 只要可以用当前物品更新，就选择该物品
    {
        ve.push_back(i);
        j-=v[i];
    }
}

for(i=0;i<ve.size();i++)
    printf("%lld ",ve[i]);
}
```



### 贪心dp
岩石怪物杜达生活在魔法森林中，他在午餐时收集了 $N$ 块能量石准备开吃。
由于他的嘴很小，所以一次只能吃一块能量石。
吃完第 $i$ 块能量石需要花费的时间为 $S_i$ 秒。
不同的能量石包含的能量可能不同。
此外，能量石会随着时间流逝逐渐失去能量。
第 $i$ 块能量石最初包含 $E_i$ 单位的能量，并且每秒将失去 $L_i$ 单位的能量。
当杜达开始吃一块能量石时，他就会立即获得该能量石所含的全部能量（无论实际吃完该石头需要多少时间）。
能量石中包含的能量最多降低至 $0$。
请问杜达通过吃能量石可以获得的最大能量是多少？

输入格式
第一行包含整数 $T$，表示共有 $T$ 组测试数据。
每组数据第一行包含整数 $N$，表示能量石的数量。
接下来 $N$ 行，每行包含三个整数 $S_i,E_i,L_i$。

<h3>输出格式</h3>
每组数据输出一个结果，每个结果占一行。
结果表示为 Case #x: y，其中 $x$ 是组别编号（从 $1$ 开始），$y$ 是可以获得的最大能量值。

数据范围
$1 \leq T \leq 10$,
$1 \leq N \leq 100$,
$1 \leq S_i \leq 100$,
$1 \leq E_i \leq 10^5$,
$0 \leq L_i \leq 10^5$

> 先贪心处理每个能量石的优先级，按优先级先后一次对dp\[i]进行更新，dp\[i]表示当前i时刻最大能量

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=105;
using namespace std;

ll dp[maxn*maxn];

struct Node{
    ll s,e,l;
double rd;
}nd[maxn];
ll n;

bool cmp(const struct Node& a,const struct Node& b)
{
        return a.rd>b.rd;
}

int main(){
ll i,j;
ll T;
ll cs=0;
cin>>T;

while(T--)
{
    memset(dp,0,sizeof(dp));
    cin>>n;
    ll maxt=0;
    for(i=1;i<=n;i++)
    {
        scanf("%lld%lld%lld",&nd[i].s,&nd[i].e,&nd[i].l);
        maxt+=nd[i].s;
        nd[i].rd=(nd[i].l*1.0)/nd[i].s;
    }
    
    sort(nd+1,nd+n+1,cmp);
    
    for(i=1;i<=n;i++)
    {
        ll s=nd[i].s,e=nd[i].e,l=nd[i].l;

        for(j=maxt-s+1;j>=1;j--)
        {
            dp[j+s-1]=max(dp[j+s-1],dp[j-1]+max((ll)0,e-(j-1)*l));
        }
        ll maxs=0;
        
        for(j=1;j<=maxt;j++)
        {
            maxs=max(maxs,dp[j]);
            dp[j]=maxs;
        }
    }
    printf("Case #%lld: %lld\n",++cs,dp[maxt]);
}
}
```





## 状态机模型

### 股票买卖 IV
给定一个长度为 $N$ 的数组，数组中的第 $i$ 个数字表示一个给定股票在第 $i$ 天的价格。
设计一个算法来计算你所能获取的最大利润，你最多可以完成 $k$ 笔交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。

输入格式
第一行包含整数 $N$ 和 $k$，表示数组的长度以及你可以完成的最大交易数量。
第二行包含 $N$ 个不超过 $10000$ 的正整数，表示完整的数组。

输出格式
输出一个整数，表示最大利润。

数据范围
$1 \leq N \leq 10^5$,
$1 \leq k \leq 100$

> 对第几次买入卖出、到第几天分别进行状态定义。dp\[0]保存卖入当前股票后所剩的利润，到下一次卖出时加上即可更新卖出值（即dp\[1]），反过来用dp\[1]更新dp\[0]就是上一步dp\[1]-当前股票价格
>
> 注意要更新0位的dp[0]为-第一支股票价格。否则会出现第一位加多的情况

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e5+5;
using namespace std;

ll dp[5][105];
ll a[maxn];
ll n,m;

int main(){
ll i,j,k;

cin>>n>>m;

for(i=1;i<=n;i++)
    scanf("%lld",&a[i]);

for(i=0;i<=m;i++)
    dp[0][i]=-a[1];

for(i=1;i<=n;i++)
for(j=m;j>=1;j--)
{
    dp[1][j]=max(dp[1][j],dp[0][j]+a[i]);
    dp[0][j]=max(dp[0][j],dp[1][j-1]-a[i]);
}    

ll ans=0;
for(i=1;i<=m;i++)
    ans=max(ans,dp[1][i]);

printf("%lld\n",ans);
}
```



### 设计密码
你现在需要设计一个密码 $S$，$S$ 需要满足：

* $S$ 的长度是 $N$；
* $S$ 只包含小写英文字母；
* $S$ 不包含子串 $T$；

例如：$abc$ 和 $abcde$ 是 $abcde$ 的子串，$abd$ 不是 $abcde$ 的子串。
请问共有多少种不同的密码满足要求？
由于答案会非常大，请输出答案模 $10^9+7$ 的余数。

输入格式
第一行输入整数N，表示密码的长度。
第二行输入字符串T，T中只包含小写字母。

输出格式
输出一个<strong>正整数</strong>，表示总方案数模 $10^9+7$ 后的结果。

数据范围
$1 \leq N \leq 50$,
$1 \leq |T| \leq N$，$|T|$是$T$的长度。

#### 自己做法

> 类似于数位dp的方式，先对子串进行KMP得到每个点匹配到前面的某个位置。dp[i]状态表示为字符串与匹配子串最长后缀长为i的数量。 对dp的递推可以理解为当前位+A~Z 26个字母，根据KMP得到+对应字母以后得到的最长后缀，再用其更新对应dp值即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=55;
const ll mod=1e9+7;
using namespace std;

ll dp[5][maxn];
ll ne[maxn];
set<char> se;
char ch[maxn];
ll n;
ll len;

int main(){
ll i,j;
cin>>n>>(ch+1);
len=strlen(ch+1);

for (i = 2, j = 0; i <= len; i ++ )
{
    while (j!=0 && ch[i] != ch[j + 1]) j = ne[j];
    if (ch[i] == ch[j + 1]) j ++ ;
    ne[i] = j;
}

dp[1][0]=1;ll p=1;

for(i=1;i<=n;i++)
{
    p^=1;
    memset(dp[p],0,sizeof(dp[p]));
    
    for(j=0;j<len;j++)
    {
        ll fro=j;
        se.clear();
        while(1)
        {
            if(se.count(ch[fro+1])==0)
            {
                dp[p][fro+1]=(dp[p][fro+1]+dp[p^1][j])%mod;
                se.insert(ch[fro+1]);
            }
            if(fro==0)    break;
            fro=ne[fro];
        }
        dp[p][0]=(dp[p][0]+dp[p^1][j]*(26-se.size()))%mod;
        
    }
}
ll ans=0;
for(i=0;i<len;i++)
    ans=(ans+dp[p][i])%mod;

printf("%lld\n",ans);
}
```



#### 一般做法

> 也是类似的思路，只不过实现方法变为遍历$a$~$z$，用其更新dp值

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=55;
const ll mod=1e9+7;
using namespace std;

char ch[maxn];  ll len;
ll dp[maxn][maxn];
ll n;
ll ne[maxn];

int main(){
ll i,j;

cin>>n;
scanf("%s",ch+1);
len=strlen(ch+1);

for(i=2,j=0;i<=len;i++)
{
    while(j!=0&&ch[j+1]!=ch[i]) j=ne[j];
    if(ch[j+1]==ch[i])  j++;
    ne[i]=j;
}

dp[0][0]=1;

for(i=1;i<=n;i++)
for(j=0;j<len;j++)
{
    for(char c='a';c<='z';c++)
    {
        ll u=j;
        while(u!=0&&ch[u+1]!=c) u=ne[u];  // 从后往前找第一个匹配的子串
        if(ch[u+1]==c)  u++;
        if(u<len)   dp[i][u]=(dp[i][u]+dp[i-1][j])%mod;  
    }
            
}

ll ans=0;
for(i=0;i<len;i++)
    ans=(ans+dp[n][i])%mod;

printf("%lld\n",ans);    
}
```



### 修复DNA
简单起见，DNA看作是一个由&rsquo;A&rsquo;, &lsquo;G&rsquo; , &lsquo;C&rsquo; , &lsquo;T&rsquo;构成的字符串。
修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。
例如，我们可以通过改变两个字符，将DNA片段&rdquo;AAGCAG&rdquo;变为&rdquo;AGGCAC&rdquo;，从而使得DNA片段中不再包含致病片段&rdquo;AAG&rdquo;，&rdquo;AGC&rdquo;，&rdquo;CAG&rdquo;，以达到修复该DNA片段的目的。
需注意，被修复的DNA片段中，仍然只能包含字符&rsquo;A&rsquo;, &lsquo;G&rsquo; , &lsquo;C&rsquo; , &lsquo;T&rsquo;。
请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。

输入格式
输入包含多组测试数据。
每组数据第一行包含整数N，表示致病DNA片段的数量。
接下来N行，每行包含一个长度不超过20的非空字符串，字符串中仅包含字符&rsquo;A&rsquo;, &lsquo;G&rsquo; , &lsquo;C&rsquo; , &lsquo;T&rsquo;，用以表示致病DNA片段。
再一行，包含一个长度不超过1000的非空字符串，字符串中仅包含字符&rsquo;A&rsquo;, &lsquo;G&rsquo; , &lsquo;C&rsquo; , &lsquo;T&rsquo;，用以表示待修复DNA片段。
最后一组测试数据后面跟一行，包含一个0，表示输入结束。

输出格式
每组数据输出一个结果，每个结果占一行。
输入形如&rdquo;Case x: y&rdquo;，其中x为测试数据编号（从1开始），y为修复过程中所需改变的字符数量的最小值，如果无法修复给定DNA片段，则y为&rdquo;-1&rdquo;。

数据范围
$1 \leq N \leq 50$

> 运用状态机+AC自动机，dp\[]为当前到AC自动机上的某个位置，然后根据接下来字符是否与AC自动机上下一个点相同以及是否与模式串相同来更新状态

```c++
#include <iostream>
#include <cstring>
#include <stdio.h>
#include <queue>
#define inf 0x3f3f3f3f
typedef long long ll;
const ll maxn=1e3+5;
using namespace std;

ll dp[5][maxn];
char ch[maxn];
ll trie[maxn][10];  ll idx;
ll fail[maxn];
bool tag[maxn];
ll n;

ll GetId(char c)
{
    if(c=='A')  return 1;
    if(c=='G')  return 2;
    if(c=='C')  return 3;
    return 4;
}

void Init()
{
    memset(tag,0,sizeof(tag));
    memset(trie,0,sizeof(trie));
    memset(fail,0,sizeof(fail));
    idx=0;
}

void Insert()
{
    ll i,j;ll len=strlen(ch+1);
    ll p=0;
    for(i=1;i<=len;i++)
    {
        ll c=GetId(ch[i]);
        if(trie[p][c]==0)
            trie[p][c]=++idx;
        p=trie[p][c];
    }
    tag[p]=1;
}

void Build()
{
    ll i,j;
    queue<ll> que;

    for(i=1;i<=4;i++)
    if(trie[0][i]!=0)
        que.push(trie[0][i]);

    while(!que.empty())
    {
        ll u=que.front();que.pop();

        for(i=1;i<=4;i++)
        {
            if(trie[u][i]!=0)
            {
                fail[trie[u][i]]=trie[fail[u]][i];
                tag[trie[u][i]]|=tag[fail[trie[u][i]]];
                que.push(trie[u][i]);
            }
            else
                trie[u][i]=trie[fail[u]][i];
        }
    }

}

int main(){
ll i,j;
ll cs=0;

while(~scanf("%lld",&n)&&n)
{
    Init();

    for(i=1;i<=n;i++)
    {
        scanf("%s",ch+1);
        Insert();
    }

    Build();

    scanf("%s",ch+1);
    ll len=strlen(ch+1);

    memset(dp,inf,sizeof(dp));
    dp[0][0]=0;
    ll pv=0;
    for(i=1;i<=len;i++)
    {
        pv^=1;
        memset(dp[pv],inf,sizeof(dp[pv]));

        for(j=0;j<=idx;j++)
        for(ll k=1;k<=4;k++)
        {
            ll plu=GetId(ch[i])!=k?1:0;
            ll p=trie[j][k];
            if(!tag[p]) dp[pv][p]=min(dp[pv][p],dp[pv^1][j]+plu);
        }

    }

    ll ans=inf;
    for(i=0;i<=idx;i++)
        ans=min(ans,dp[pv][i]);

    if(ans==inf)    ans=-1;
    if(cs!=0)   printf("\n");
    printf("Case %lld: %lld",++cs,ans);

}
}

```





## 状压dp



### 小国王
在 $n \times n$ 的棋盘上放 $k$ 个国王，国王可攻击相邻的 $8$ 个格子，求使它们无法互相攻击的方案总数。

输入格式
共一行，包含两个整数 $n$ 和 $k$。

输出格式
共一行，表示方案总数，若不能够放置则输出$0$。

数据范围
$1 \leq n \leq 10$,
$0 \leq k \leq n^2$

> dp两个状态，一个是当前行所表示国王位置，另一个是当前国王总数。更新即可
>
> 表示国王位置可离散所有可能位置，即用vector存可能位置，vector下标即为对应可能位置

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=10;
using namespace std;

ll dp[5][1005][105];
vector<ll> ve;
vector<ll> sz;
ll n,m;

void Init()
{
    ll i,j;
    for(i=0;i<(1<<n);i++)
    {
        if((i&(i>>1))==0)
        {
            ve.push_back(i);
            ll cnt=0;
            for(j=0;j<=11;j++)
                cnt+=((i>>j)&1);
            sz.push_back(cnt);
        }
    }
}


int main(){
ll i,j,k;

cin>>n>>m;

Init();
dp[0][0][0]=1;
ll p=0;

for(k=1;k<=n;k++)
{
    p^=1;
    memset(dp[p],0,sizeof dp[p]);
    for(i=0;i<ve.size();i++)
    for(j=0;j<ve.size();j++)
    if( (ve[i]&(ve[j]>>1))==0 && ((ve[i]>>1)&ve[j])==0 && (ve[i]&ve[j])==0 )  // 注意要判断不存在的三种情况
    {
        for(ll l=sz[j];l<=m-sz[i];l++)
            dp[p][i][l+sz[i]]+=dp[p^1][j][l];
    }
    
}

ll ans=0;

for(i=0;i<ve.size();i++)
    ans+=dp[p][i][m];

printf("%lld\n",ans);
    
}
```



### 愤怒的小鸟
Kiana 最近沉迷于一款神奇的游戏无法自拔。
简单来说，这款游戏是在一个平面上进行的。
有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟， 小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a<0$。
当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。
在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $(x_i,y_i)$。
如果某只小鸟的飞行轨迹经过了 $(x_i, y_i)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；
如果一只小鸟的飞行轨迹没有经过 $(x_i, y_i)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。
例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y= x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。
而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。
这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个这个游戏。
这些指令将在输入格式中详述。
假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。
由于她不会算，所以希望由你告诉她。

输入格式
第一行包含一个正整数 $T$，表示游戏的关卡总数。
下面依次输入这 $T$ 个关卡的信息。
每个关卡第一行包含两个非负整数 $n,m$，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。
接下来的 $n$ 行中，第 $i$ 行包含两个正实数 $(x_i,y_i)$，表示第 $i$ 只小猪坐标为 $(x_i,y_i)$，数据保证同一个关卡中不存在 两只坐标完全相同的小猪。
如果 $m=0$，表示 Kiana 输入了一个没有任何作用的指令。
如果 $m=1$，则这个关卡将会满足：至多用  $⌈n/3+1⌉$ 只小鸟即可消灭所有小猪。
如果 $m=2$，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少 $⌊n/3⌋$ 只小猪。
保证 $1 \le n \le 18，0 \le m \le 2，0<x_i,y_i<10$，输入中的实数均保留到小数点后两位。

输出格式
对每个关卡依次输出一行答案。
输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。

> m没有任何意义。该抛物线是以y轴为对称轴的一条开口向下的抛物线，两点可以确定一条该类抛物线，要保证$a<0$。先取两点确认一条抛物线后，遍历其他点，如果有点在抛物线上，便加入该抛物线的“状态”。获得所有抛物线“状态”后，从前往后遍历所有小猪的”状态”，用抛物线的“状态”更新即可。

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=20;
const double eps=1e-14;
using namespace std;

double x[maxn],y[maxn];

ll n,m;
ll dp[1<<maxn];
ll path[maxn][maxn];

bool Equal(double a,double b)
{
    return fabs(a-b)<eps;
}

void GetAB(ll p,ll q,double& a,double& b)
{
    double A1=pow(x[p],2),A2=x[p],A3=y[p];
    double B1=pow(x[q],2),B2=x[q],B3=y[q];
    
    B2-=B1/A1*A2;B3-=B1/A1*A3;B1-=B1/A1*A1;
    b=B3/B2;
    a=(A3-b*A2)/A1;
}

bool InLine(ll p,double a,double b)
{
    return Equal(pow(x[p],2)*a+x[p]*b,y[p]);
}

void InitPath()
{
    ll i,j,k;double a,b;
    memset(path,0,sizeof(path));
    
    for(i=1;i<=n;i++)
    {
        path[i][i]=(1<<(i-1));
        for(j=1;j<=n;j++)
        {
            if(Equal(x[i],x[j]))   continue;  // 两点x轴坐标相同，形成直线
            GetAB(i,j,a,b);
            if(a>=0)   continue;
            path[i][j]=(1<<(i-1))|(1<<(j-1));
            
            for(k=1;k<=n;k++)
            {
                if(InLine(k,a,b))
                {
                    path[i][j]|=(1<<(k-1));
                }
            }
            
        }  
    }
}


int main(){
ll i,j,k;ll T;
cin>>T;

while(T--)
{
    cin>>n>>m;
    memset(dp,0x3f3f3f3f,sizeof(dp));
    dp[0]=0;
    for(i=1;i<=n;i++)
        scanf("%lf%lf",&x[i],&y[i]);
    
    InitPath();
    ll p;    
    for(i=0;i<(1<<n)-1;i++)
    {
        for(j=0;j<n;j++)
        if(((i>>j)&1)==0)
        {
            p=j+1;break;   
        }
        
        for(j=1;j<=n;j++)
        {
            ll x=i|path[p][j];
            dp[x]=min(dp[x],dp[i]+1);
        }
    }
    printf("%lld\n",dp[(1<<n)-1]);
}

}
```



### 宝藏
参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋，也给出了这 $n$ 个宝藏屋之间可供开发的 $m$  条道路和它们的长度。
小明决心亲自前往挖掘所有宝藏屋中的宝藏。
但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。
小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。
在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。
已经开凿出的道路可以任意通行不消耗代价。
每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。
另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。
新开发一条道路的代价是：
这条道路的长度 $×$ 从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋）。
请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。

输入格式
第一行两个用空格分离的正整数 $n$ 和 $m$，代表宝藏屋的个数和道路数。
接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏屋的编号（编号为 $1 \sim n$），和这条道路的长度 $v$。

输出格式
输出共一行，一个正整数，表示最小的总代价。

数据范围
$1 \le n \le 12$,
$0 \le m \le 1000$,
$v \le 5*10^5$

> 用类似最小生成树的解法，状压dp的两个状态分别为当前最大深度以及状压的当前宝藏状态，当前的最优状态一定是由前一个深度的某个最优状态更新而来。所以可以预处理出所有满足条件的递推宝藏状态及其花费，更新即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll inf=1e12;
const ll maxn=15;
using namespace std;

ll n,m;
ll dp[1<<maxn][maxn];
ll gra[maxn][maxn];
vector<ll> ve[1<<maxn];
vector<ll> sz[1<<maxn];

void Init()
{
    ll i,j,k;
    
    for(i=0;i<=(1<<n);i++)
    for(j=1;j<=n;j++)
        dp[i][j]=inf;
        
    for(i=0;i<n;i++)
        dp[1<<i][1]=0;
    
    for(i=0;i<(1<<n);i++)
    {
        for(j=(i-1)&i;j!=0;j=(j-1)&i)  // 得到所有i状态的子集j
        {
            ll st=i^j;  // 因为j是i的子集，所以^得到i有的j没有的宝藏
            ll cnt=0;
            ll l;
            
            for(l=0;l<n;l++)
            {
                if(((st>>l)&1)==1)
                {
                    ll plu=inf;
                    
                    for(k=1;k<=n;k++)
                    if(((j>>(k-1))&1)==1)
                        plu=min(plu,gra[l+1][k]);
                        
                    if(plu>=inf)    break;  // 当前某个宝藏点不能有上一步的状态到达
                    cnt+=plu;                        
                }
            }
            if(l==n)
            {
                ve[i].push_back(j);
                sz[i].push_back(cnt);
            }            
        }
    }
}

int main(){
ll i,j,k;ll a,b,c;

cin>>n>>m;

for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
    gra[i][j]=inf;

for(i=1;i<=m;i++)
{
    scanf("%lld%lld%lld",&a,&b,&c);
    gra[a][b]=min(gra[a][b],c);
    gra[b][a]=min(gra[b][a],c);
}

Init();

for(i=2;i<=n;i++)
{
    for(j=0;j<(1<<n);j++)
    {
        for(k=0;k<ve[j].size();k++)
        {
            dp[j][i]=min(dp[ve[j][k]][i-1]+sz[j][k]*(i-1),dp[j][i]);  // 遍历深度更新
        }
    }
}

ll ans=inf;
for(i=1;i<=n;i++)
    ans=min(ans,dp[(1<<n)-1][i]);

printf("%lld\n",ans);

}
```





## 区间dp



### 加分二叉树
设一个 $n$ 个节点的二叉树 tree 的中序遍历为（$1,2,3,…,n$），其中数字 $1,2,3,…,n$ 为节点编号。
每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：
subtree的左子树的加分 $×$ subtree的右子树的加分 $＋$ subtree的根的分数
若某个子树为空，规定其加分为 $1$。
叶子的加分就是叶节点本身的分数，不考虑它的空子树。
试求一棵符合中序遍历为（$1,2,3,…,n$）且加分最高的二叉树 tree。
要求输出：
（1）tree的最高加分
（2）tree的前序遍历

输入格式
第 $1$ 行：一个整数 $n$，为节点个数。
第 $2$ 行：$n$ 个用空格隔开的整数，为每个节点的分数（$0<$分数$<100$）。

输出格式
第 $1$ 行：一个整数，为最高加分（结果不会超过int范围）。
第 $2$ 行：$n$ 个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。

数据范围
$n < 30$

输入样例：
5
5 7 1 2 10

输出样例：
145
3 1 2 4 5

> 中序遍历可以理解为区间dp中合并时左中右区间，所以对其进行区间dp并保存每个区间的最优中点，最后dfs即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=35;
using namespace std;

ll dp[maxn][maxn];
ll node[maxn][maxn];
ll a[maxn];
ll n;

void dfs(ll l,ll r)
{
    if(l>r) return;
    printf("%lld ",node[l][r]);
    dfs(l,node[l][r]-1);
    dfs(node[l][r]+1,r);
}

int main(){
ll i,j,k;

cin>>n;

for(i=1;i<=n;i++)
    scanf("%lld",&a[i]);
    
for(i=1;i<=n;i++)
for(j=1;j<=n-i+1;j++)   
for(k=j;k<=j+i-1;k++)
{
    if(i==1)
    {
        dp[j][j]=a[j];
        node[j][j]=j;
        continue;
    }
    if(k==j)    dp[j][k-1]=1;
    if(k==j+i-1)    dp[k+1][j+i-1]=1;
    if(dp[j][j+i-1]<dp[j][k-1]*dp[k+1][j+i-1]+a[k])
    {
        dp[j][j+i-1]=dp[j][k-1]*dp[k+1][j+i-1]+a[k];
        node[j][j+i-1]=k;
    }
}

printf("%lld\n",dp[1][n]);

dfs(1,n);
}
```



### 凸多边形的划分
给定一个具有 $N$ 个顶点的凸多边形，将顶点从 $1$ 至 $N$ 标号，每个顶点的权值都是一个正整数。
将这个凸多边形划分成 $N-2$ 个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形 的顶点权值乘积之和至少为多少。

输入格式
第一行包含整数 $N$，表示顶点数量。
第二行包含 $N$ 个整数，依次为顶点 $1$ 至顶点 $N$ 的权值。

输出格式
输出仅一行，为所有三角形的顶点权值乘积之和的最小值。

数据范围
$N \le 50$,
数据保证所有顶点的权值都小于$10^9$

输入样例：
5
121 122 123 245 231

输出样例：
12214884

> 数据较大，用__int128或vector存数。用区间dp的思想，遍历每个区间内所有点当做k点，更新即可

```c++
#include <bits/stdc++.h>
typedef __int128 ints;
typedef long long ll;
const ll maxn=55;
using namespace std;

ll n;
ints dp[maxn][maxn];
ints a[maxn];

ints Read()
{
    ints x=0;
    char c;
    while(c=getchar())
    {
        if(c>='0'&&c<='9')
            x=x*10+c-'0';
        else
            break;
    }
    return x;
}

void Write(ints x)
{
    if(x>9)
        Write(x/10);
    putchar('0'+x%10);
}

void Init()
{
    ll i,j,k;
    ints x=1;
    for(i=1;i<=40;i++)  x*=10;

    for(i=0;i<maxn;i++)
    for(j=0;j<maxn;j++)
        dp[i][j]=x;
}

int main(){
ll i,j,k;
ll n;

cin>>n;
getchar();
for(i=1;i<=n;i++)
    a[i]=Read();


Init();

for(i=1;i<=n;i++)
for(j=1;j<=n-i+1;j++)
{
    if(i<=2)
    {
        dp[j][j+i-1]=0;
    }
    for(k=j+1;k<j+i-1;k++)
    {
        if(dp[j][j+i-1]>dp[j][k]+dp[k][j+i-1]+a[j]*a[j+i-1]*a[k])
        {
            dp[j][j+i-1]=dp[j][k]+dp[k][j+i-1]+a[j]*a[j+i-1]*a[k];
        }
    }
}

Write(dp[1][n]);
printf("\n");
}
```



### 棋盘分割

将一个 $8 \times 8$ 的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了 $(n-1)$ 次后，连同最后剩下的矩形棋盘共有 $n$ 块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行)
![](https://www.acwing.com/media/article/image/2019/02/05/19_32dad08629-1191_1.jpg)
原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。
现在需要把棋盘按上述规则分割成 $n$ 块矩形棋盘，并使各矩形棋盘总分的均方差最小。
![](https://www.acwing.com/media/article/image/2019/02/05/19_566d096029-formula.png)
请编程对给出的棋盘及 $n$，求出均方差的最小值。

输入格式
第 $1$ 行为一个整数 $n$。
第 $2$ 行至第 $9$ 行每行为 $8$ 个小于 $100$ 的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。

输出格式
输出最小均方差值（四舍五入精确到小数点后三位）。

数据范围
$1 < n < 15$

输入样例：
3
1 1 1 1 1 1 1 3
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 0
1 1 1 1 1 1 0 3

输出样例：
1.633

> 先将式子分解，可以得到式子最小时满足$x_i$<sup>2</sup>和最小，因此对每个矩形的$x_i$<sup>2</sup>和进行dp，即dp状态表示为某个矩形划分若干次最小$x_i$<sup>2</sup>和，每次区间更新，分别行更新和列更新。最后对dp值求解处理即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=15;
using namespace std;

ll gra[maxn][maxn];
ll node[maxn][maxn];
ll dp[maxn][maxn][maxn][maxn][20];
ll n=8,m;

ll GetPowArea(ll p,ll pl,ll q,ll ql)
{
    return (gra[pl][ql]-gra[pl][q-1]-gra[p-1][ql]+gra[p-1][q-1])*(gra[pl][ql]-gra[pl][q-1]-gra[p-1][ql]+gra[p-1][q-1]);
}

int main(){
ll i,j,k;
cin>>m;

memset(dp,0x3f3f3f3f3f3f3f3f,sizeof(dp));

for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
    scanf("%lld",&node[i][j]);

for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
    gra[i][j]=node[i][j]+gra[i-1][j]+gra[i][j-1]-gra[i-1][j-1];

for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
{
    for(k=1;k<=m;k++)
    {
        for(ll p=1;p<=n-i+1;p++)
        for(ll q=1;q<=n-j+1;q++)
        {
            ll pl=p+i-1;ll ql=q+j-1;
            if(k==1)
            {
                dp[p][pl][q][ql][1]=GetPowArea(p,pl,q,ql);
                continue;
            }
            for(ll l=p;l<=pl;l++)
            {
                dp[p][pl][q][ql][k]=min(dp[p][pl][q][ql][k],dp[p][l][q][ql][k-1]+GetPowArea(l+1,pl,q,ql));
                dp[p][pl][q][ql][k]=min(dp[p][pl][q][ql][k],dp[l][pl][q][ql][k-1]+GetPowArea(p,l-1,q,ql));
            }
            for(ll l=q;l<=ql;l++)
            {
                dp[p][pl][q][ql][k]=min(dp[p][pl][q][ql][k],dp[p][pl][q][l][k-1]+GetPowArea(p,pl,l+1,ql));
                dp[p][pl][q][ql][k]=min(dp[p][pl][q][ql][k],dp[p][pl][l][ql][k-1]+GetPowArea(p,pl,q,l-1));
            }
                
        }        
    }
}

double avg=gra[n][n]*1.0/m;
double ans=(dp[1][n][1][n][m]*1.0+avg*avg*m*1.0-2.0*avg*gra[n][n]);
printf("%.3f\n",sqrt(ans/m));

}
```





## 树形dp



### 树的最长路径

给定一棵树，树中包含 $n$ 个结点（编号$1$~$n$）和 $n-1$ 条无向边，每条边都有一个权值。
现在请你找到树中的一条最长路径。
换句话说，要找到一条路径，使得使得路径两端的点的距离最远。
注意：路径中可以只包含一个点。

输入格式
第一行包含整数 $n$。
接下来 $n-1$ 行，每行包含三个整数 $a_i,b_i,c_i$，表示点 $a_i$ 和 $b_i$ 之间存在一条权值为 $c_i$ 的边。

输出格式
输出一个整数，表示树的最长路径的长度。

数据范围
$1 \le n \le 10000$,
$1 \le a_i,b_i \le n$,
$-10^5 \le c_i \le 10^5$

输入样例：
6
5 1 6
1 4 5
6 3 9
2 6 8
6 1 7

输出样例：
22

#### dp做法

> 在树上，最长路径可以由每个节点的最大和次大子节点的路径长更新得来

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e4+5;
using namespace std;

vector<ll> nd[maxn];
vector<ll> val[maxn];
vector<ll> sz[maxn];
ll n;
ll ans=0;
ll rt=1;

ll dfs(ll u,ll f)
{
    ll i,j;
    ll max1=0,max2=0;
    
    for(i=0;i<nd[u].size();i++)
    {
        if(nd[u][i]==f) continue;
        
        ll x=dfs(nd[u][i],u)+val[u][i];     
        if(x>=max1)
        {
            max2=max1;
            max1=x;
        }
        else if(x>=max2)
        {
            max2=x;
        }
    }
    ans=max(ans,max1+max2);
    return max1;
}

int main(){
ll i,j;
ll a,b,c;
cin>>n;

for(i=1;i<n;i++)
{
    scanf("%lld%lld%lld",&a,&b,&c);
    nd[a].push_back(b);val[a].push_back(c);
    nd[b].push_back(a);val[b].push_back(c);
}

dfs(rt,0);

printf("%lld\n",ans);

}
```



#### 找两次最长距离

> 根据树的特性，先找距离某个节点最远的点，再找该点在树上的最远距离。即两次dfs找最远路径。
>
> （个人理解：对于一条树的直径两端的节点，如果某个节点的最远距离点不是他俩其中一个，那么一定可以通过该节点转接成为一条更长的直径）

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e4+5;
using namespace std;

vector<ll> nd[maxn];
vector<ll> val[maxn];
vector<ll> sz[maxn];
ll n;
ll ans=0;
ll rt=1;

ll dfs(ll u,ll f)
{
    ll i,j;
    ll max1=0,max2=0;
    
    for(i=0;i<nd[u].size();i++)
    {
        if(nd[u][i]==f) continue;
        
        ll x=dfs(nd[u][i],u)+val[u][i];     
        if(x>=max1)
        {
            max2=max1;
            max1=x;
        }
        else if(x>=max2)
        {
            max2=x;
        }
    }
    ans=max(ans,max1+max2);
    return max1;
}

int main(){
ll i,j;
ll a,b,c;
cin>>n;

for(i=1;i<n;i++)
{
    scanf("%lld%lld%lld",&a,&b,&c);
    nd[a].push_back(b);val[a].push_back(c);
    nd[b].push_back(a);val[b].push_back(c);
}

dfs(rt,0);

printf("%lld\n",ans);

}
```



### 数字转换
如果一个数 $x$ 的约数之和 $y$（不包括他本身）比他本身小，那么 $x$ 可以变成 $y$，$y$ 也可以变成 $x$。
例如，$4$ 可以变为 $3$，$1$ 可以变为 $7$。
限定所有数字变换在不超过 $n$ 的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。

输入格式
输入一个正整数 $n$。

输出格式
输出不断进行数字变换且不出现重复数字的最多变换步数。

数据范围
$1 \le n \le 50000$

输入样例：
7


输出样例：
3

样例解释
一种方案为：$4 \to 3 \to 1 \to 7$。

> 建一个特殊的树，该树满足子节点和父节点满足变换关系且子节点小于父节点，也就是从小到大建点，每个点的父节点是约数之和比他本身小的树，建有向边即可。然后对每个点求两条最长子路径之和即是答案。
>
> 因每个点只有一个父节点，也就是说求一条不重复的最长边时只能是“先上后下”形式

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=5e4+5;
using namespace std;

vector<ll> pri;
bool ispri[maxn];
vector<ll> ve[maxn];
ll n;
unordered_map<ll,ll> ump;
ll rt=1;
ll ans=0;

void InitPri()
{
    ll i,j;
    memset(ispri,1,sizeof(ispri));
    ispri[0]=ispri[1]=0;
    for(i=2;i<maxn;i++)
    {
        if(ispri[i])
            pri.push_back(i);
        for(j=0;j<pri.size()&&pri[j]*i<maxn;j++)
        {
            ispri[pri[j]*i]=0;
            if(i%pri[j]==0)  break;
        }
    }
}

ll GetYue(ll x)
{
    ll i,j,k;
    ump.clear();
    ll xl=x;
    for(i=0;i<maxn;i++)
    {
        while(xl%pri[i]==0)
        {
            ump[pri[i]]++;
            xl/=pri[i];
        }
        if(xl==1)   break;
    }
    ll res=1;
    for(auto it=ump.begin();it!=ump.end();it++)
    {
        ll a=it->first;ll b=it->second;
        ll sum=1;ll o=1;
        for(i=1;i<=b;i++)
        {
            o*=a;
            sum+=o;
        }
        res*=sum;
    }
    return res-x;  // 这里约数不包括自己本身
}

ll dfs(ll u)
{
    ll i,j;
    ll max1=0,max2=0;ll x;
    for(i=0;i<ve[u].size();i++)
    {
        x=dfs(ve[u][i]);
        if(x>=max1)
        {
            max2=max1;
            max1=x;
        }
        else if(x>max2)
        {
            max2=x;
        }
    }
    ans=max(ans,max1+max2+1);
    return max1+1;
}

int main(){
ll i,j;

InitPri();

cin>>n;

for(i=2;i<=n;i++)
{
    ll x=GetYue(i);

   if(x<i)
    ve[x].push_back(i);
}

dfs(rt);

printf("%lld\n",ans-1);

}
```



### 二叉苹果树
有一棵二叉苹果树，如果树枝有分叉，一定是分两叉，即没有只有一个儿子的节点。
这棵树共 $N$ 个节点，编号为 $1$ 至 $N$，树根编号一定为 $1$。
我们用一根树枝两端连接的节点编号描述一根树枝的位置。
一棵苹果树的树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。
这里的保留是指最终与1号点连通。

输入格式
第一行包含两个整数 $N$ 和 $Q$，分别表示树的节点数以及要保留的树枝数量。
接下来 $N-1$ 行描述树枝信息，每行三个整数，前两个是它连接的节点的编号，第三个数是这根树枝上苹果数量。

输出格式
输出仅一行，表示最多能留住的苹果的数量。

数据范围
$1 \le Q \lt N \le 100$.
$N \neq 1$,
每根树枝上苹果不超过 $30000$ 个。

输入样例：
5 2
1 3 1
1 4 10
2 3 20
3 5 20

输出样例：
21

> 题意是指在一颗苹果树上选一个子树（没要求仍是苹果树），使得该子树不超过q条边且价值最大。用树形dp，dp状态为以当前点为子树根节点且不超过某数量边的最大价值，然后从下往上更新即可。

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e2+5;
using namespace std;

ll rt=1;
ll dp[maxn][maxn];
vector<ll> ve[maxn];
vector<ll> val[maxn];
ll n,q;

void dfs(ll u,ll f)
{
    ll i,j;
    
    ll l=-1,r=-1;
    for(i=0;i<ve[u].size();i++)
    {
        if(ve[u][i]==f) continue;
        dfs(ve[u][i],u);
        if(l==-1)   l=i;
        else if(r==-1)  r=i;
    }
    if(ve[u].size()==1)   return;
    for(i=1;i<=q;i++)
    {
        for(j=0;j<=i-2;j++)
        {
            ll k=i-2-j;
            dp[u][i]=max(dp[u][i],dp[ve[u][l]][j]+dp[ve[u][r]][k]+val[u][l]+val[u][r]);  // 根节点选两条边的情况
        }
        dp[u][i]=max(dp[u][i],dp[ve[u][l]][i-1]+val[u][l]);  // 根节点只选一条边的情况
        dp[u][i]=max(dp[u][i],dp[ve[u][r]][i-1]+val[u][r]);
    }
}


int main(){
ll i,j;
ll a,b,c;
cin>>n>>q;

for(i=1;i<n;i++)
{
    scanf("%lld%lld%lld",&a,&b,&c);
    ve[a].push_back(b);val[a].push_back(c);
    ve[b].push_back(a);val[b].push_back(c);
}

dfs(1,-1);

printf("%lld\n",dp[1][q]);

}
```



### 战略游戏
鲍勃喜欢玩电脑游戏，特别是战略游戏，但有时他找不到解决问题的方法，这让他很伤心。
现在他有以下问题。
他必须保护一座中世纪城市，这条城市的道路构成了一棵树。
每个节点上的士兵可以观察到所有和这个点相连的边。
他必须在节点上放置最少数量的士兵，以便他们可以观察到所有的边。
你能帮助他吗？
例如，下面的树：
![](D:/TyporaPhotoCache/19_0f47f44029-1463_1.jpg-16356845967514.gif)
只需要放置 $1$ 名士兵（在节点 $1$ 处)，就可观察到所有的边。

输入格式
输入包含多组测试数据，每组测试数据用以描述一棵树。
对于每组测试数据，第一行包含整数 $N$，表示树的节点数目。
接下来 $N$ 行，每行按如下方法描述一个节点。
节点编号：(子节点数目) 子节点 子节点 $\cdots$
节点编号从 $0$ 到 $N-1$，每个节点的子节点数量均不超过 $10$，每个边在输入数据中只出现一次。

输出格式
对于每组测试数据，输出一个占据一行的结果，表示最少需要的士兵数。

数据范围
$0 < N \le 1500$

输入样例：
4
0:(1) 1
1:(2) 2 3
2:(0)
3:(0)
5
3:(3) 1 4 2
1:(1) 0
2:(0)
0:(0)
4:(0)

输出样例：
1
2

> 题意就是让每一条边都有至少一个点为1，定义dp状态为以该点为根节点的子树且该点为0或1的最小操作次数，再找未被指向的点作为树的根节点，从下往上更新即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=2e3+5;
using namespace std;

vector<ll> ve[maxn];
ll dp[maxn][5];
bool st[maxn];
ll n;
ll rt;

void dfs(ll u)
{
    ll i,j;
    dp[u][0]=0;dp[u][1]=1;

    for(i=0;i<ve[u].size();i++)
    {
        dfs(ve[u][i]);
        dp[u][0]+=dp[ve[u][i]][1];
        dp[u][1]+=min(dp[ve[u][i]][0],dp[ve[u][i]][1]);
    }
}

int main(){
ll i,j;ll x;ll a,b;

while(~scanf("%lld",&n))
{
    for(i=0;i<=n+1;i++)
        ve[i].clear();
    memset(st,0,sizeof(st));
    for(i=1;i<=n;i++)
    {
        scanf("%lld:(%lld)",&x,&a);
        x++;
        for(j=1;j<=a;j++)
        {
            scanf("%lld",&b);
            b++;
            ve[x].push_back(b);
            st[b]=1;
        }
    }
    
    memset(dp,0x3f3f3f3f,sizeof(dp));
    
    rt=1;
    while(st[rt])   rt++;
    dfs(rt);
    printf("%lld\n",min(dp[rt][1],dp[rt][0]));
}

}
```



### 皇宫看守
太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。
皇宫各个宫殿的分布，呈一棵树的形状，宫殿可视为树中结点，两个宫殿之间如果存在道路直接相连，则该道路视为树中的一条边。
已知，在一个宫殿镇守的守卫不仅能够观察到本宫殿的状况，还能观察到与该宫殿直接存在道路相连的其他宫殿的状况。
大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。
可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。
帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。

输入格式
输入中数据描述一棵树，描述如下：
第一行 $n$，表示树中结点的数目。
第二行至第 $n+1$ 行，每行描述每个宫殿结点信息，依次为：该宫殿结点标号 $i$，在该宫殿安置侍卫所需的经费 $k$，该结点的子结 点数 $m$，接下来 $m$ 个数，分别是这个结点的 $m$ 个子结点的标号 $r_1,r_2,\cdots,r_m$。
对于一个 $n$ 个结点的树，结点标号在 $1$ 到 $n$ 之间，且标号不重复。

输出格式
输出一个整数，表示最少的经费。

数据范围
$1 \le n \le 1500$

输入样例：
6
1 30 3 2 3 4
2 16 2 5 6
3 5 0
4 4 0
5 11 0
6 5 0

输出样例：
25

> 题意是当每个点被定为1时，直接相连的点均变为1，让所有点变为1的最小操作次数。定义dp某个点的三个状态分别为在以该点为根节点的子树上，1被选在当前节点的最小操作次数、1被选在根节点的子节点的最小操作次数，1被选在根节点的子节点的子节点的最小操作次数。然后更新即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=2e3+5;
using namespace std;

ll dp[maxn][5];  // 1为放在当前根节点，2为放在当前根节点的子节点，3为当前根节点的父节点需要放入（即当前只有根节点没有1）
vector<ll> ve[maxn];
ll w[maxn];
bool st[maxn];
ll n;
ll rt;

void dfs(ll u)
{
    ll i,j;
    
    if(ve[u].empty())
    {
        dp[u][1]=w[u];dp[u][3]=0;
        return;
    }
    ll cnta=0,cntb=0;
    for(i=0;i<ve[u].size();i++)
    {
        dfs(ve[u][i]);
        cnta+=min(dp[ve[u][i]][1],min(dp[ve[u][i]][2],dp[ve[u][i]][3]));  
        cntb+=min(dp[ve[u][i]][1],dp[ve[u][i]][2]);  //在某些情况下，2未必比1小，例如叶子结点的父节点
    }
    dp[u][1]=cnta+w[u];
    for(i=0;i<ve[u].size();i++)
    {
        dp[u][2]=min(dp[u][2],cntb-min(dp[ve[u][i]][1],dp[ve[u][i]][2])+dp[ve[u][i]][1]);  // 只要有一个子节点是状态1即可
    }
    dp[u][3]=cntb;
}

int main(){
ll i,j;
ll x,a,b,c;
cin>>n;
memset(dp,0x3f3f3f,sizeof dp);
for(i=1;i<=n;i++)
{
    scanf("%lld",&x);
    scanf("%lld",&w[x]);
    scanf("%lld",&a);
    for(j=1;j<=a;j++)
    {
        scanf("%lld",&b);
        ve[x].push_back(b);
        st[b]=1;
    }
}

rt=1;
while(st[rt])   rt++;
dfs(rt);

printf("%lld\n",min(dp[rt][1],dp[rt][2]));
}
```





## 数位dp



### 度的数量
求给定区间 $[X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和。
例如，设 $X = 15, Y = 20, K = 2, B = 2$，则有且仅有下列三个数满足题意：
$17 = 2^4 + 2^0$
$18 = 2^4 + 2^1$
$20 = 2^4 + 2^2$

输入格式
第一行包含两个整数 $X$ 和 $Y$，接下来两行包含整数 $K$ 和 $B$。

输出格式
只包含一个整数，表示满足条件的数的个数。

数据范围
$1 \le X \le Y \le 2^{31}-1$,
$1 \le K \le 20$,
$2 \le B \le 10$

输入样例：
15 20
2
2

输出样例：
3

> 用数位dp求解，把数转化为对应的b进制数，然后每位限定为0或1，求刚好有k位为1且不超过原数大小的数量
>
> 从高位往低位遍历，碰到0继续，碰到1更新当前位为0后面位为对应数量1的值，碰到大于1更新当前位分别为0和1后面对应数量1的值并且结束，因为不会再出现别的可能。对应数量是指k-前面出现1的次数。因为前面出现1后，继续遍历时是指前面的1不变时的取值
>
> 组合数递推公式:$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$

#### 写法一

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=35;
using namespace std;

ll C[maxn][maxn];
ll k,b;

void InitC()
{
    ll i,j;
    for(i=0;i<maxn;i++)
    for(j=0;j<=i;j++)
    {
        if(j==0)    C[i][j]=1;
        else    C[i][j]=C[i-1][j]+C[i-1][j-1];
    }
}

ll Solve(ll x)
{
    if(x==0)    return 0;
    ll i,j;
    ll res=0;
    vector<ll> ve;
    ll xl=x;
    while(xl!=0)
    {
        ve.push_back(xl%b);xl/=b;
    }
    ll last=0;
    for(i=ve.size()-1;i>=0;i--)
    {
        ll o=ve[i];
        if(o>0)
        {
            res+=C[i][k-last];
            if(o>1)
            {
                if(k-last-1>=0)
                    res+=C[i][k-last-1];
                break;
            }
            else
            {
                last++;
                if(last>k)  break;
            }
        }
     
    }
    if(i==-1&&last==k)   res++;   
    
    return res;
}

int main(){
ll i,j;
ll x,y;
InitC();

cin>>x>>y>>k>>b;
    
cout<<Solve(y)-Solve(x-1)<<endl;
    
}
```



#### 写法二

```c++
// 记忆化dp
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=35;
using namespace std;

ll f[maxn][maxn];  // 保存任意取时的值
ll a[maxn];
ll l,r,k,b;

ll dp(ll pos,ll st,ll op)
{
    if(pos==0)  return st==k;  // 特判自身为合法情况
    if(op==0&&f[pos][st]!=-1)   return f[pos][st];  // 在任意取时返回已知值
    ll res=0;ll maxx=op==1?min(a[pos],(ll)1):1; 
    for(ll i=0;i<=maxx;i++)
    {
        if(i+st>k)  break;
        res+=dp(pos-1,st+i,op==1&&a[pos]==i);   
    }
    return op==1?res:f[pos][st]=res;
}

ll GetSum(ll x)
{
    ll p=0;
    while(x!=0)
    {
        a[++p]=x%b;
        x/=b;
    }
    return dp(p,0,1);
}

int main(){

memset(f,-1,sizeof f);
    
cin>>l>>r>>k>>b;
cout<<GetSum(r)-GetSum(l-1)<<endl;
    
}
```







### 数字游戏
科协里最近很流行数字游戏。
某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 $123$，$446$。
现在大家决定玩一个游戏，指定一个整数闭区间 $[a,b]$，问这个区间内有多少个不降数。

输入格式
输入包含多组测试数据。
每组数据占一行，包含两个整数 $a$ 和 $b$。

输出格式
每行给出一组测试数据的答案，即 $[a,b]$ 之间有多少不降数。

数据范围
$1 \le a \le b \le 2^{31}-1$

输入样例：
1 9
1 19

输出样例：
9
18

> 和上题类似思路，先初始化以$i$为起始长度为$j$的不降数数量，然后从前往后遍历处理，注意到达最后一步特判该值即为不降数的情况

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=15;
using namespace std;

ll amo[15][15];
vector<ll> ve;

void InitAmo()
{
    ll i,j,k;
    for(i=9;i>=0;i--)
    {
        amo[i][1]=1;
        for(j=2;j<=10;j++)
        for(k=i;k<=9;k++)
        {
            amo[i][j]+=amo[k][j-1];
        }
    }
}

ll GetSum(ll x)
{
    ll i,j;
    ve.clear();
    ll xl=x;
    ll res=0;
    while(xl!=0)
    {
        ve.push_back(xl%10);
        xl/=10;
    }
    ll last=0;
    for(i=ve.size()-1;i>=0;i--)
    {
        for(j=last;j<ve[i];j++)
            res+=amo[j][i+1];
        if(last>ve[i])  break;
        last=ve[i];
    }
    if(i==-1)   res++;
    return res;
}

int main(){
ll i,j;
ll a,b;

InitAmo();

while(~scanf("%lld%lld",&a,&b))
{
    printf("%lld\n",GetSum(b)-GetSum(a-1));
}

}
```



### Windy数
Windy 定义了一种 Windy 数：不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 Windy 数。
Windy 想知道，在 $A$ 和 $B$ 之间，包括 $A$ 和 $B$，总共有多少个 Windy 数？

输入格式
共一行，包含两个整数 $A$ 和 $B$。

输出格式
输出一个整数，表示答案。

数据范围
$1 \le A \le B \le 2 \times 10^9$

输入样例1：
1 10

输出样例1：
9


输入样例2：
25 50

输出样例2：
20

> 数位dp特殊处理前导0的情况，即先计算除最高位以外先不取0的情况，最后补上其他个位以非0开头的情况

#### 写法一

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=15;
using namespace std;

ll f[maxn][maxn]; // f[i][j]表示任意取时以i为开头长度为j的所有可能

void InitF()
{
    ll i,j,k;
    for(k=1;k<=10;k++)
    for(i=0;i<=9;i++)
    {
        if(k==1)
        {
            f[i][k]=1;continue;
        }
        for(j=0;j<=9;j++)
        if(abs(i-j)>=2)
            f[i][k]+=f[j][k-1];
    }
}

ll Get(ll x)
{
    ll i,j,k;
    if(x==0)    return 0;
    vector<ll> ve;
    while(x)
    {
        ve.push_back(x%10);
        x/=10;
    }
    reverse(ve.begin(),ve.end());
    ll last=-2;
    ll res=0;
    for(i=0;i<ve.size();i++)
    {
        for(j=(i==0);j<ve[i];j++)  // 特判最高位0的情况
        if(abs(j-last)>=2)
            res+=f[j][ve.size()-i];
        if(abs(last-ve[i])>=2)  last=ve[i];
        else    break;
    }
    
    if(i==ve.size())    res++;   
    
    for(i=1;i<ve.size();i++) // 前导0的情况
    for(j=1;j<=9;j++)
        res+=f[j][i];

    return res;
}

int main(){
ll a,b;
InitF();

cin>>a>>b;

printf("%lld\n",Get(b)-Get(a-1));

}
```

#### 写法二

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=15;
using namespace std;

ll f[maxn][maxn];
ll a[maxn];

ll dp(ll pos,ll st,ll op)
{
    if(pos==0)  return 1;
    if(op==0&&f[pos][st]!=-1)   return f[pos][st];
    ll res=0;ll maxx=op==1?a[pos]:9;
    for(ll i=0;i<=maxx;i++)
    if(abs(i-st)>=2)
        res+=dp(pos-1,(!i&&st==-2)?-2:i,op&&i==a[pos]);  
    return op?res:f[pos][st]=res;
}

ll Get(ll x)
{
    ll p=0;
    while(x)
    {
        a[++p]=x%10;
        x/=10;
    }
    return dp(p,-2,1);
}

int main(){
memset(f,-1,sizeof f);
ll a,b;
cin>>a>>b;

printf("%lld\n",Get(b)-Get(a-1));
}
```



### 恨7不成妻
单身！
依然单身！
吉哥依然单身！
DS 级码农吉哥依然单身！
所以，他平生最恨情人节，不管是 $214$ 还是 $77$，他都讨厌！
吉哥观察了 $214$ 和 $77$ 这两个数，发现：
$2 + 1 + 4 = 7$
$7 + 7 = 7 \times 2$
$77 = 7 \times 11$
最终，他发现原来这一切归根到底都是因为和 $7$ 有关！
所以，他现在甚至讨厌一切和 $7$ 有关的数！
什么样的数和 $7$ 有关呢？
如果一个整数符合下面三个条件之一，那么我们就说这个整数和 $7$ 有关：

* 整数中某一位是 $7$；
* 整数的每一位加起来的和是 $7$ 的整数倍；
* 这个整数是 $7$ 的整数倍。

现在问题来了：吉哥想知道在一定区间内和 $7$ 无关的整数的平方和。

输入格式
第一行包含整数 $T$，表示共有 $T$ 组测试数据。
每组数据占一行，包含两个整数 $L$ 和 $R$。

输出格式
对于每组数据，请计算 $[L,R]$ 中和 $7$ 无关的数字的平方和，并将结果对 $10^9+7$ 取模后输出。

数据范围
$1 \le T \le 50$,
$1 \le L \le R \le 10^{18}$

输入样例：
3
1 9
10 11
17 17

输出样例：
236
221

> 数位dp状态f\[数最高位的值]\[数各个位总和%7]\[数%7]\[数的位数]\[1：平方和  2：和  3：个数]
>
> 再用平方和公式更新即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll mod=1e9+7;
const ll maxn=25;
using namespace std;

ll f[15][maxn][maxn][maxn][5];
ll tens[maxn];ll tenm[maxn];

void InitTens()
{
    ll i,j;
    tens[0]=1;
    for(i=1;i<=20;i++)
        tens[i]=tens[i-1]*10%7;
}

void InitTenm()
{
    ll i,j;
    tenm[0]=1;
    for(i=1;i<=20;i++)
        tenm[i]=tenm[i-1]*10%mod;
}


void InitF()
{
    ll i,j,k,l;ll a,b;
    for(l=1;l<=20;l++)
    for(i=0;i<=9;i++)
    {
        if(l==1)
        {
            if(i!=7)
            {
                f[i][i%7][i%7][l][1]+=i*i%mod;
                f[i][i%7][i%7][l][1]%=mod;
                f[i][i%7][i%7][l][2]+=i%mod;
                f[i][i%7][i%7][l][2]%=mod;
                f[i][i%7][i%7][l][3]+=1;
                f[i][i%7][i%7][l][3]%=mod;
            }
            continue;
        }
        for(j=0;j<=9;j++)
        {
            if(j==7)    continue;
            for(a=0;a<7;a++)
            for(b=0;b<7;b++)
            {
                auto &x1=f[i][(i+a)%7][(i*tens[l-1]%7+b)%7][l][1];
                auto &x2=f[i][(i+a)%7][(i*tens[l-1]%7+b)%7][l][2];
                auto &x3=f[i][(i+a)%7][(i*tens[l-1]%7+b)%7][l][3];
                auto &v1=f[j][a][b][l-1][1];auto &v2=f[j][a][b][l-1][2];auto &v3=f[j][a][b][l-1][3];
                ll plu=tenm[l-1]*i%mod;
                x1=(x1+v1+2*v2%mod*plu%mod+v3*plu%mod*plu%mod)%mod;
                x2=(x2+v2+plu*v3%mod)%mod;
                x3=(x3+v3)%mod;
            }
        }
    }
}

ll Get(ll x)
{
    ll i,j,k;ll a,b;
    ll xl=x;
    vector<ll> ve;
    while(xl)
    {
        ve.push_back(xl%10);
        xl/=10;
    }
    reverse(ve.begin(),ve.end());

    ll sum=0,num=0;
    ll res=0;

    for(i=0;i<ve.size();i++)
    {
        for(j=0;j<ve[i];j++)
        for(a=0;a<7;a++)
        for(b=0;b<7;b++)
        {
            if(j==7)    continue;
            if((sum+a)%7!=0&&(num%7*tens[ve.size()-i]+b)%7!=0)
            {
                auto &v1=f[j][a][b][ve.size()-i][1];auto &v2=f[j][a][b][ve.size()-i][2];auto &v3=f[j][a][b][ve.size()-i][3];
                ll plu=num%mod*tenm[ve.size()-i]%mod;
                res=(res+ plu*plu%mod*v3%mod+v2*plu%mod*2%mod+v1)%mod;
            }
        }
        sum=(sum+ve[i])%7;
        num=(num*10+ve[i]);
        if(ve[i]==7)    break;
    }

    if(i==ve.size()&&sum%7!=0&&num%7!=0)
    {
        res+=x%mod*(x%mod)%mod;
    }
    res%=mod;
    return res;
}

int main(){
ll T;
ll a,b;
InitTens();
InitTenm();
InitF();

cin>>T;

while(T--)
{
    scanf("%lld%lld",&a,&b);
    printf("%lld\n",(Get(b)-Get(a-1)+mod)%mod);
}

}

```



## 单调队列优化dp



### 最大子序和
输入一个长度为 $n$ 的整数序列，从中找出一段长度不超过 $m$ 的连续子序列，使得子序列中所有数的和最大。
<strong>注意：</strong> 子序列的长度至少是 $1$。

输入格式
第一行输入两个整数 $n,m$。
第二行输入 $n$ 个数，代表长度为 $n$ 的整数序列。
同一行数之间用空格隔开。

输出格式
输出一个整数，代表该序列的最大子序和。

数据范围
$1 \le n,m \le 300000 $

输入样例：
6 4
1 -3 5 1 -2 3

输出样例：
7

> 用单调队列存范围内最小的前缀和，从前往后遍历更新值和单调队列即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=3e5+5;
using namespace std;

ll n,m;
ll a[maxn];
ll fro[maxn];
ll ans=-1e12;
ll que[maxn];

int main(){
ll i,j;

cin>>n>>m;
for(i=1;i<=n;i++)
{
    scanf("%lld",&a[i]);
    fro[i]=fro[i-1]+a[i];
}
ll l=0,r=-1;
que[++r]=0;

for(i=1;i<=n;i++)
{
    while(l<=r&&i-que[l]>m) l++;
    if(l<=r)    ans=max(ans,fro[i]-fro[que[l]]);
    while(l<=r&&fro[i]<=fro[que[r]]) r--;
    que[++r]=i;
}

printf("%lld\n",ans);
    
}
```



### 修剪草坪
在一年前赢得了小镇的最佳草坪比赛后，FJ 变得很懒，再也没有修剪过草坪。
现在，新一轮的最佳草坪比赛又开始了，FJ 希望能够再次夺冠。
然而，FJ 的草坪非常脏乱，因此，FJ 只能够让他的奶牛来完成这项工作。
FJ 有 $N$ 只排成一排的奶牛，编号为 $1$ 到 $N$。
每只奶牛的效率是不同的，奶牛 $i$ 的效率为 $E_i$。
编号相邻的奶牛们很熟悉，如果 FJ 安排超过 $K$ 只编号连续的奶牛，那么这些奶牛就会罢工去开派对。
因此，现在 FJ 需要你的帮助，找到最合理的安排方案并计算 FJ 可以得到的最大效率。
注意，方案需满足不能包含超过 $K$ 只编号连续的奶牛。

输入格式
第一行：空格隔开的两个整数 $N$ 和 $K$；
第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $E_i$。

输出格式
共一行，包含一个数值，表示 FJ 可以得到的最大的效率值。

数据范围
$1 \le N \le 10^5$,
$0 \le E_i \le 10^9$

输入样例：
5 2
1
2
3
4
5


输出样例：
12

样例解释
FJ 有 5 只奶牛，效率分别为 1、2、3、4、5。
FJ 希望选取的奶牛效率总和最大，但是他不能选取超过 2 只连续的奶牛。
因此可以选择第三只以外的其他奶牛，总的效率为 1 + 2 + 4 + 5 = 12。

> 分别设两个状态表示到达当前位的最大效率值$f$以及（用于给后面值更新的）当前最大效率值-后一位的前缀和 $g$。
>
> 更新每位的最大效率值即是前面最大的$g$+该位前缀和
>
> 用单调队列处理即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e5+5;
using namespace std;

ll fro[maxn];
ll g[maxn];
ll f[maxn];
ll que[maxn];
ll n,m;

int main(){
ll i,j;ll x;

cin>>n>>m;
for(i=1;i<=n;i++)
{
    scanf("%lld",&x);
    fro[i]=fro[i-1]+x;
}

ll hh=0,tt=-1;
que[++tt]=0;

for(i=1;i<=n;i++)
{
    if(i-que[hh]>m)   hh++;
    f[i]=max(f[i-1],fro[i]+g[que[hh]]);
    g[i]=f[i-1]-fro[i];
    while(hh<=tt&&g[que[tt]]<=g[i]) tt--;
    que[++tt]=i;
}

printf("%lld\n",f[n]);
}
```



### 旅行问题
John 打算驾驶一辆汽车周游一个环形公路。
公路上总共有 $n$ 个车站，每站都有若干升汽油（有的站可能油量为零），每升油可以让汽车行驶一千米。
John 必须从某个车站出发，一直按顺时针（或逆时针）方向走遍所有的车站，并回到起点。
在一开始的时候，汽车内油量为零，John 每到一个车站就把该站所有的油都带上（起点站亦是如此），行驶过程中不能出现没有油的情 况。
任务：判断以每个车站为起点能否按条件成功周游一周。

输入格式
第一行是一个整数 $n$，表示环形公路上的车站数；
接下来 $n$ 行，每行两个整数 $p_i,d_i$，分别表示表示第 $i$ 号车站的存油量和第 $i$ 号车站到 <strong>顺时针方向</strong> 下一站的距离。

输出格式
输出共 $n$ 行，如果从第 $i$ 号车站出发，一直按顺时针（或逆时针）方向行驶，能够成功周游一圈，则在第 $i$ 行输出 TAK，否则 输出 NIE。

数据范围
$3 \le n \le 10^6$,
$0 \le p_i \le 2 \times 10^9$,
$0 \le d_i \le 2 \times 10^9$

输入样例：
5
3 1
1 2
5 2
0 1
5 4

输出样例：
TAK
NIE
TAK
NIE
TAK

> 单调队列保存前面一圈范围内的前缀和，分顺时针和逆时针两次处理。处理即维护单调队列和对应的“标准值”（即当前到1的前缀和-前面已经不在该一圈范围内的前缀和），判断条件是最小单调队列值-“标准值”小于0就不可以继续走（等于0的时候也视为可以走的情况）。

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=2e6+5;
using namespace std;

ll a[maxn];ll b[maxn];
ll inv[maxn];
ll que[maxn];
bool flag[maxn];
bool ans[maxn];
ll n;

int main(){
ll i,j;

cin>>n;
for(i=1;i<=n;i++)
    scanf("%lld%lld",&a[i],&b[i]);

ll hh=0,tt=-1;
inv[1]=0;
a[0]=a[n];b[0]=b[n];
que[++tt]=1;
flag[1]=1;
ll pov=0;

for(i=2;i<=2*n;i++)
{
    ll p=(i-1)%n+1;
    inv[i]=inv[i-1]+a[p-1]-b[p-1];

    while(hh<=tt&&inv[que[tt]]>=inv[i])  tt--;
    que[++tt]=i;
    
    if(!flag[p])    
        flag[p]=1;
    else
    {
        while(hh<=tt&&i-que[hh]>=n)  hh++;
        //if(p==1)    cout<<" "<<inv[que[hh]]<<" "<<que[hh]<<" "<<pov<<endl;
        if(inv[que[hh]]+pov>=0)  ans[p]=1; 
        pov+=-a[p]+b[p];
    }
}


// 逆时针

memset(flag,0,sizeof flag);
memset(inv,0,sizeof inv);
hh=0,tt=-1;
pov=0;

for(i=1;i<=n/2;i++)
    swap(a[i],a[n+1-i]);
for(i=1;i<=(n-1)/2;i++)
    swap(b[i],b[(n-1)+1-i]);

a[0]=a[n];b[0]=b[n];
que[++tt]=1;
flag[1]=1;

for(i=2;i<=2*n;i++)
{
    ll p=(i-1)%n+1;
    inv[i]=inv[i-1]+a[p-1]-b[p-1];

    while(hh<=tt&&inv[que[tt]]>=inv[i])  tt--;
    que[++tt]=i;
    
    if(!flag[p])    
        flag[p]=1;
    else
    {
        while(hh<=tt&&i-que[hh]>=n)  hh++;
        if(inv[que[hh]]+pov>=0)  ans[n+1-p]=1; 
        pov+=-a[p]+b[p];
    }
}

for(i=1;i<=n;i++)
    ans[i]?puts("TAK"):puts("NIE");
    
}
```



### 烽火传递
烽火台是重要的军事防御设施，一般建在交通要道或险要处。
一旦有军情发生，则白天用浓烟，晚上有火光传递军情。
在某两个城市之间有 $n$ 座烽火台，每个烽火台发出信号都有一定的代价。
为了使情报准确传递，在连续 $m$ 个烽火台中至少要有一个发出信号。
现在输入 $n,m$ 和每个烽火台的代价，请计算在两城市之间准确传递情报所需花费的总代价最少为多少。

输入格式
第一行是两个整数 $n,m$，具体含义见题目描述；
第二行 $n$ 个整数表示每个烽火台的代价 $a_i$。

输出格式
输出仅一个整数，表示最小代价。

数据范围
$1 \le n,m \le 2 \times 10^5$,
$0 \le a_i \le 1000$

输入样例：
5 3
1 2 5 6 2

输出样例：
4

> 保存dp状态为选了当前位置后的最小代价，单调队列放入前面可用于更新的范围内的dp状态。再更新即可

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=2e5+5;
using namespace std;

ll n,m;
ll a[maxn];
ll que[maxn];
ll f[maxn];

int main(){
ll i,j;

cin>>n>>m;
for(i=1;i<=n;i++)
    scanf("%lld",&a[i]);

ll hh=0,tt=-1;
que[++tt]=0;

for(i=1;i<=n;i++)
{
    while(hh<=tt&&i-que[hh]>m)  hh++;
    f[i]=f[que[hh]]+a[i];
    while(hh<=tt&&f[que[tt]]>=f[i]) tt--;
    que[++tt]=i;
}

ll ans=1e12;
for(i=max((ll)0,n-m+1);i<=n;i++)
    ans=min(ans,f[i]);

printf("%lld\n",ans);
}
```



### 绿色通道
高二数学《绿色通道》总共有 $n$ 道题目要抄，编号 $1,2,\cdots,n$，抄第 $i$ 题要花 $a_i$ 分钟。
小 Y 决定只用不超过 $t$ 分钟抄这个，因此必然有空着的题。
每道题要么不写，要么抄完，不能写一半。
下标连续的一些空题称为一个空题段，它的长度就是所包含的题目数。
这样应付自然会引起马老师的愤怒，最长的空题段越长，马老师越生气。
现在，小 Y 想知道他在这 $t$ 分钟内写哪些题，才能够尽量减轻马老师的怒火。
由于小 Y 很聪明，你只要告诉他最长的空题段至少有多长就可以了，不需输出方案。

输入格式
第一行为两个整数 $n,t$。
第二行为 $n$ 个整数，依次为 $a_1,a_2,\cdots,a_n$。

输出格式
输出一个整数，表示最长的空题段至少有多长。

数据范围
$0 < n \le 5 \times 10^4$,
$0 < a_i \le 3000$,
$0 < t \le 10^8$

输入样例：
17 11
6 4 5 2 5 3 4 5 2 3 4 5 2 3 6 3 5

输出样例：
3

> 单调队列+二分查找，即二分查找选len，单调队列处理求最小值。

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=5e4+5;
using namespace std;

ll a[maxn];
ll que[maxn];
ll f[maxn];
ll n,m;

ll GetVal(ll len)
{
    ll i,j,k;
    ll hh=0,tt=-1;
    
    que[++tt]=0;
    
    for(i=1;i<=n;i++)
    {
        while(hh<=tt&&i-que[hh]>len+1)  hh++;
        f[i]=f[que[hh]]+a[i];
        while(hh<=tt&&f[i]<=f[que[tt]]) tt--;
        que[++tt]=i;
    }
    ll res=1e12;
    for(i=max((ll)0,n-len);i<=n;i++)
        res=min(res,f[i]);
    return res;
}

ll GetAns()
{
    ll l=-1,r=n+1;
    
    while(l+1<r)
    {
        ll mid=(l+r)>>1;
        if(GetVal(mid)<=m)
            r=mid;
        else
            l=mid;
    }
    return r;
}

int main(){
ll i,j;

cin>>n>>m;

for(i=1;i<=n;i++)
    scanf("%lld",&a[i]);

ll ans=GetAns();

printf("%lld\n",ans);

}
```



### 理想的正方形
有一个 $a \times b$ 的整数组成的矩阵，现请你从中找出一个 $n \times n$ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。

输入格式
第一行为三个整数，分别表示 $a,b,n$ 的值；
第二行至第 $a+1$ 行每行为 $b$ 个非负整数，表示矩阵中相应位置上的数。

输出格式
输出仅一个整数，为 $a \times b$ 矩阵中所有"$n \times n$ 正方形区域中的最大整数和最小整数的差值"的最小值。

数据范围
$2 \le a,b \le 1000$,
$n \le a,n \le b,n \le 100$,
矩阵中的所有数都不超过 $10^9$。

输入样例：
5 4 2
1 2 5 6
0 17 16 0
16 17 2 1
2 10 2 1
1 2 2 2

输出样例：
1

> 运用二维滑动窗口模型+单调队列优化，即先处理每一行的（最小值or最大值），在处理每一列（已获得的（最小值or最大值））的（最小值or最大值）。注意每次获得的值要保存到一个新的数组里，否则遍历时后面会调用到前面以更新的最值，而不是本身的最值

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e3+5;
using namespace std;

ll gra[maxn][maxn];
ll que[maxn];
ll min_row[maxn][maxn];ll max_row[maxn][maxn];
ll mins_col[maxn];ll maxs_col[maxn];
ll mins[maxn];ll maxs[maxn];

void Get_min(ll a[],ll b[],ll n,ll m)
{
    ll i,j;
    ll hh=0,tt=-1;
    for(i=n;i>=1;i--)
    {
        while(hh<=tt&&a[que[tt]]>=a[i]) tt--;
        que[++tt]=i;
        while(hh<=tt&&que[hh]-i>=m) hh++;
        b[i]=a[que[hh]];
    }
}

void Get_max(ll a[],ll b[],ll n,ll m)
{
    ll i,j;
    ll hh=0,tt=-1;
    for(i=n;i>=1;i--)
    {
        while(hh<=tt&&a[que[tt]]<=a[i]) tt--;
        que[++tt]=i;
        while(hh<=tt&&que[hh]-i>=m) hh++;
        b[i]=a[que[hh]];
    }
}

int main(){
ll i,j,k;
ll n,m,len;

cin>>n>>m>>len;

for(i=1;i<=n;i++)
for(j=1;j<=m;j++)
    scanf("%lld",&gra[i][j]);

for(i=1;i<=n;i++)
{
    Get_min(gra[i],min_row[i],m,len);
    Get_max(gra[i],max_row[i],m,len);
}
ll ans=1e12;
for(j=1;j<=m-len+1;j++)
{
    for(i=1;i<=n;i++)
    {
        mins_col[i]=min_row[i][j];
        maxs_col[i]=max_row[i][j];
    }
    Get_min(mins_col,mins,n,len);
    Get_max(maxs_col,maxs,n,len);
    for(k=1;k<=n-len+1;k++)
        ans=min(ans,maxs[k]-mins[k]);
}

printf("%lld\n",ans);
}
```



## 斜率优化DP



### 任务安排2
有 $N$ 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。
机器会把这 $N$ 个任务分成若干批，每一批包含连续的若干个任务。
从时刻 $0$ 开始，任务被分批加工，执行第 $i$ 个任务所需的时间是 $T_i$。
另外，在每批任务开始前，机器需要 $S$ 的启动时间，故执行一批任务所需的时间是启动时间 $S$ 加上每个任务所需时间之和。
一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。
也就是说，同一批任务将在同一时刻完成。
每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。
请为机器规划一个分组方案，使得总费用最小。

输入格式
第一行包含整数 $N$。
第二行包含整数 $S$。
接下来 $N$ 行每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间 $T_i$ 及其费用系数 $C_i$。

输出格式
输出一个整数，表示最小总费用。

数据范围
$1 \le N \le 3 \times 10^5$,
$1 \le T_i,C_i \le 512$,
$0 \le S \le 512$

输入样例：
5
1
1 3
3 2
4 3
2 3
1 4

输出样例：
153

> 首先DP状态每次更新当前对后面的所有影响
>
> 则更新过程为$f_i=f_j+m*(b_n-b_j)+a_i*(b_i-b_j)  $（$m$表示$S$,$a_i$表示$T_i$，$b_i$表示$C_i$）
>
> 优化后公式为$f_i=(m+a_i)*b_j+f_i-m*b_n-a_i*b_i$
>
> 可理解为$k==(m+a_i)的$$y=kx+b$
>
> 单调队列维护连续两点之间的斜率，根据凸包知识得到单调队列前两元素如果 斜率<=$k$，也就需要被弹出
>
> 第一个$k$应该大于当前的$m+a_i$
>
> 然后更新$f_i$
>
> 最后放入时如果队列末端的$k$如果大于等于要放入的$k$，则弹出队列末端元素

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=3e5+5;
using namespace std;

ll n,m;
ll a[maxn];ll b[maxn];
ll f[maxn];
ll que[maxn];ll hh=0,tt=-1;

int main(){
ll i,j;

cin>>n>>m;
for(i=1;i<=n;i++)
{
    scanf("%lld",&a[i]);
    a[i]+=a[i-1];
    scanf("%lld",&b[i]);
    b[i]+=b[i-1];
}

memset(f,0x3f3f3f3f3f3f3f3f,sizeof f);
f[0]=0;
que[++tt]=0;

for(i=1;i<=n;i++)
{
    while(hh<tt&&(f[que[hh+1]]-f[que[hh]])<=(b[que[hh+1]]-b[que[hh]])*(m+a[i])) hh++;
    f[i]=f[que[hh]]+m*(b[n]-b[que[hh]])+a[i]*(b[i]-b[que[hh]]);
    while(hh<tt&&(f[que[tt]]-f[que[tt-1]])*(b[i]-b[que[tt]])>=(f[i]-f[que[tt]])*(b[que[tt]]-b[que[tt-1]]))  tt--;
    que[++tt]=i;
}

printf("%lld\n",f[n]);
}
```



### 任务安排3
有 $N$ 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。
机器会把这 $N$ 个任务分成若干批，每一批包含连续的若干个任务。
从时刻 $0$ 开始，任务被分批加工，执行第 $i$ 个任务所需的时间是 $T_i$。
另外，在每批任务开始前，机器需要 $S$ 的启动时间，故执行一批任务所需的时间是启动时间 $S$ 加上每个任务所需时间之和。
一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。
也就是说，同一批任务将在同一时刻完成。
每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。
请为机器规划一个分组方案，使得总费用最小。


输入格式
第一行包含两个整数 $N$ 和 $S$。
接下来 $N$ 行每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间 $T_i$ 及其费用系数 $C_i$。

输出格式
输出一个整数，表示最小总费用。

数据范围
$1 \le N \le 3 \times 10^5$,
$0 \le S,C_i \le 512$,
$-512 \le T_i \le 512$

输入样例：
5 1
1 3
3 2
4 3
2 3
1 4

输出样例：
153

> 与上题不同之处在于$T_i$取值有负数情况，也就是斜率不一定单调递增，这时候单调栈仍维护单调递增的$k$，用二分找第一个$\le$$(m+a_i)$即可

```c++
#include<bits/stdc++.h>
typedef long long ll;
const ll maxn=3e5+5;
using namespace std;

ll a[maxn];ll b[maxn];
ll f[maxn];
ll que[maxn];ll hh=0,tt=-1;
ll n,m;

ll Find(ll x)
{
    ll l=hh,r=tt;
    while(l<r)
    {
        ll mid=l+r>>1;
        if((f[que[mid+1]]-f[que[mid]])<=(m+x)*(b[que[mid+1]]-b[que[mid]]))
            l=mid+1;
        else
            r=mid;
    }
    return que[r];
}

int main(){
ll i,j;

cin>>n>>m;

que[++tt]=0;

for(i=1;i<=n;i++)
{
    scanf("%lld%lld",&a[i],&b[i]);
    a[i]+=a[i-1];
    b[i]+=b[i-1];
}

for(i=1;i<=n;i++)
{
    j=Find(a[i]);
    f[i]=f[j]-(a[i]+m)*b[j]+a[i]*b[i]+m*b[n];
    while(hh<tt&&(double)(f[que[tt]]-f[que[tt-1]])*(b[i]-b[que[tt-1]])>=(double)(f[i]-f[que[tt-1]])*(b[que[tt]]-b[que[tt-1]])) tt--;
    que[++tt]=i;
}

printf("%lld\n",f[n]);
}

```



### 运输小猫
小 $S$ 是农场主，他养了 $M$ 只猫，雇了 $P$ 位饲养员。
农场中有一条笔直的路，路边有 $N$ 座山，从 $1$ 到 $N$ 编号。
第 $i$ 座山与第 $i-1$ 座山之间的距离为 $D_i$。
饲养员都住在 $1$ 号山。
有一天，猫出去玩。
第 $i$ 只猫去 $H_i$ 号山玩，玩到时刻 $T_i$ 停止，然后在原地等饲养员来接。
饲养员们必须回收所有的猫。
每个饲养员沿着路从 $1$ 号山走到 $N$ 号山，把各座山上已经在等待的猫全部接走。
饲养员在路上行走需要时间，速度为 $1$ 米/单位时间。
饲养员在每座山上接猫的时间可以忽略，可以携带的猫的数量为无穷大。
例如有两座相距为 $1$ 的山，一只猫在 $2$ 号山玩，玩到时刻 $3$ 开始等待。
如果饲养员从 $1$ 号山在时刻 $2$ 或 $3$ 出发，那么他可以接到猫，猫的等待时间为 $0$ 或 $1$。
而如果他于时刻 $1$ 出发，那么他将于时刻 $2$ 经过 $2$ 号山，不能接到当时仍在玩的猫。
你的任务是规划每个饲养员从 $1$ 号山出发的时间，使得所有猫等待时间的总和尽量小。
饲养员出发的时间可以为负。

输入格式
第一行包含三个整数 $N，M，P$。
第二行包含 $n-1$ 个整数，$D_2,D_3,\cdots,D_N$。
接下来 $M$ 行，每行包含两个整数 $H_i$ 和 $T_i$。

输出格式
输出一个整数，表示所有猫等待时间的总和的最小值。

数据范围
$2 \le N \le 10^5$,
$1 \le M \le 10^5$,
$1 \le P \le 100$,
$1 \le D_i < 1000$,
$1 \le H_i \le N$,
$0 \le T_i \le 10^9$

输入样例：
4 6 2
1 3 5
1 0
2 1
4 9
1 10
2 10
3 12

输出样例：
3



> 把题意转化为小猫需要饲养员出发的时间，排序后可以得到贪心策略，即饲养员一定会选择某只猫需要的出发时间。然后前面未带走的猫则根据公式可以算出最小时间
>
> 公式：
>
> $a_i$是该猫需要饲养员出发的时间，$b_i$是对$a_i$排序后的前缀和
>
> 遍历饲养员的数量，对于当前饲养员的数量$k$，$f_i=f_j+(i-j)*a_i-(b_i-b_j)$。其中$f_i$是$dp[k][i]$，$f_j$是$dp[k-1][j]$
>
> 公式等价于$ (f_j+b_j)=(f_i+b_i)-(i-j)*a_i $。所以把公式等价于$y$为$f_i+b_i$，$k$为$a_i$，$x$为$j$，$-i*a_i$为$b$的斜率方程
>
> 处理斜率方程即可求解

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=1e5+5;
using namespace std;

ll hill[maxn];
ll f[105][maxn];
ll a[maxn];ll b[maxn];
ll m,n,amo;
ll que[maxn];ll hh,tt;

int main(){
ll i,j;

cin>>m>>n>>amo;

for(i=2;i<=m;i++)
{
    scanf("%lld",&hill[i]);
    hill[i]+=hill[i-1];
}

for(i=1;i<=n;i++)
{
    scanf("%lld%lld",&a[i],&b[i]);
    a[i]=hill[a[i]];
    a[i]=b[i]-a[i];
}

sort(a+1,a+n+1);

for(i=1;i<=n;i++)
    b[i]=b[i-1]+a[i];

memset(f,0x3f3f3f3f3f3f3f3f,sizeof f);
for(i=0;i<=amo;i++)
    f[i][0]=0;

for(ll k=1;k<=amo;k++)
{
    hh=0,tt=-1;que[++tt]=0;
    for(i=1;i<=n;i++)
    {
        while(hh<tt&&(f[k-1][que[hh+1]]-f[k-1][que[hh]])<=a[i]*(que[hh+1]-que[hh]) )  hh++;
        j=que[hh];
        f[k][i]=f[k-1][j]-j*a[i]+i*a[i];
        while(hh<tt&&(f[k-1][que[tt]]-f[k-1][que[tt-1]])*(i-que[tt-1])>=(f[k-1][i]-f[k-1][que[tt-1]])*(que[tt]-que[tt-1]) ) tt--;
        que[++tt]=i;
    }
}

ll ans=0x3f3f3f3f3f3f3f3f;
for(i=1;i<=amo;i++)
    ans=min(ans,f[i][n]);

printf("%lld\n",ans-b[n]);
}
```





## 双端队列广搜

### 电路维修
达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。
翰翰的家里有一辆飞行车。
有一天飞行车的电路板突然出现了故障，导致无法启动。
电路板的整体结构是一个 $R$ 行 $C$ 列的网格（$R,C≤500$），如下图所示。
![](D:/TyporaPhotoCache/19_be6ff7a219-%E7%94%B5%E8%B7%AF.png)
每个格点都是电线的接点，每个格子都包含一个电子元件。
电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。
在旋转之后，它就可以连接另一条对角线的两个接点。
电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。
达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。
她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。
不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。
注意：只能走斜向的线段，水平和竖直线段不能走。

输入格式
输入文件包含多组测试数据。
第一行包含一个整数 $T$，表示测试数据的数目。
对于每组测试数据，第一行包含正整数 $R$ 和 $C$，表示电路板的行数和列数。
之后 $R$ 行，每行 $C$ 个字符，字符是"/"和"\"中的一个，表示标准件的方向。

输出格式
对于每组测试数据，在单独的一行输出一个正整数，表示所需的最小旋转次数。
如果无论怎样都不能使得电源和发动机之间连通，输出 NO SOLUTION。

数据范围
$1 \le R,C \le 500$,
$1 \le T \le 5$

输入样例：
1
3 5
\\/\\
\\///
/\\\\

输出样例：
1

样例解释
样例的输入对应于题目描述中的情况。
只需要按照下面的方式旋转标准件，就可以使得电源和发动机之间连通。
![](D:/TyporaPhotoCache/19_a0e8e80a19-%E7%94%B5%E8%B7%AF2.png)

> 用类似dijkstra的思路和双端队列结合，对于每个点，看其对角线上的四个点，如果当前有斜线直接连接，则更新权值并放入队列前面，否则更新权值放入队列末尾。

```c++
#include <bits/stdc++.h>
typedef long long ll;
const ll maxn=5e2+5;
using namespace std;

bool gra[maxn][maxn];
ll f[maxn][maxn];
bool st[maxn][maxn];
char ch[maxn];
ll n,m;
deque<pair<pair<ll,ll>,ll> > deq;

bool Exi(ll a,ll b)
{
    return a>=0&&a<=n&&b>=0&&b<=m&&(!st[a][b]);
}

int main(){
ll i,j;
ll a,b;
ll T;

cin>>T;
while(T--)
{
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=n;i++)
    {
        scanf("%s",ch+1);
        for(j=1;j<=m;j++)
            gra[i][j]=(ch[j]=='\\');
    }
    
    memset(st,0,sizeof st);

    while(!deq.empty()) deq.pop_front();

    deq.push_front({{0,0},0});

    while(!deq.empty())
    {
        ll a=deq.front().first.first;ll b=deq.front().first.second;ll c=deq.front().second;
        deq.pop_front();
        f[a][b]=c;
        st[a][b]=1;
        if(a==n&&b==m)  break;

        ll al,bl;
        if(Exi(a+1,b+1))
        {
            al=a+1;bl=b+1;
            if(gra[a+1][b+1])
                deq.push_front({{al,bl},c});
            else
                deq.push_back({{al,bl},c+1});
        }
        if(Exi(a+1,b-1))
        {
            al=a+1;bl=b-1;
            if(!gra[a+1][b])
                deq.push_front({{al,bl},c});
            else
                deq.push_back({{al,bl},c+1});
        }
        if(Exi(a-1,b-1))
        {
            al=a-1;bl=b-1;
            if(gra[a][b])
                deq.push_front({{al,bl},c});
            else
                deq.push_back({{al,bl},c+1});
        }
        if(Exi(a-1,b+1))
        {
            al=a-1;bl=b+1;
            if(!gra[a][b+1])
                deq.push_front({{al,bl},c});
            else
                deq.push_back({{al,bl},c+1});
        }
    }
    if(st[n][m])
        printf("%lld\n",f[n][m]);
    else
        printf("NO SOLUTION\n");
}

}
```





## 双向广搜

### 字串变换
已知有两个字串 $A$, $B$ 及一组字串变换的规则（至多 $6$ 个规则）:
$A_1 \to B_1$
$A_2 \to B_2$
$\cdots$
规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$、$A_2$ 可以变换为 $B_2…$。
例如：$A$＝abcd $B$＝xyz
变换规则为：
abc $\to$ xu ud $\to$ y y $\to$ yz
则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：
abcd $\to$ xud $\to$ xy $\to$ xyz
共进行了三次变换，使得 $A$ 变换为 $B$。

输入格式
输入格式如下：
$A$   $B$
$A_1$ $B_1$
$A_2$ $B_2$
$\cdots$   $\cdots$
第一行是两个给定的字符串 $A$ 和 $B$。
接下来若干行，每行描述一组字串变换的规则。
所有字符串长度的上限为 $20$。

输出格式
若在 $10$ 步（包含 $10$ 步）以内能将 $A$ 变换为 $B$ ，则输出最少的变换步数；否则输出 NO ANSWER!。

输入样例：
abcd xyz
abc xu
ud y
y yz

输出样例：
3

> 双向广搜即对起点和终点分别进行广搜，以降低时间复杂度。如当前不超过10步，则对两点分别进行最大5步的广搜。在第二次广搜时更新ans

```c++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

unordered_map<string,ll> ump1;
unordered_map<string,ll> ump2;
vector<pair<string,string> > ve;
string beg,ed;
string str_a,str_b;
queue<string>que;

ll ans=15;

void bfs1()
{
    while(!que.empty()) que.pop();
    que.push(beg);
    string s;

    while(!que.empty())
    {
        s=que.front();que.pop();

        if(s==ed)
        {
            ans=ump1[s];
            break;
        }
        if(ump1[s]==5)   break;

        for(ll i=0;i<s.size();i++)
        for(ll j=0;j<ve.size();j++)
        {
            str_a=ve[j].first;
            str_b=ve[j].second;
            if(s.substr(i,str_a.size())==str_a )
            {
                string sl=s;
                sl.replace(i,str_a.size(),str_b,0,str_b.size());
                if(ump1[sl]==0)
                {
                    ump1[sl]=ump1[s]+1;
                    que.push(sl);
                }
            }
        }
    }
}

void bfs2()
{
    while(!que.empty()) que.pop();
    que.push(ed);

    string s;

    while(!que.empty())
    {
        s=que.front();que.pop();

        if(ump1[s]!=0)  ans=min(ans,ump1[s]+ump2[s]);

        if(ump2[s]==5)   break;

        for(ll i=0;i<s.size();i++)
        for(ll j=0;j<ve.size();j++)
        {
            str_a=ve[j].first;
            str_b=ve[j].second;
            if(s.substr(i,str_b.size())==str_b )
            {
                string sl=s;
                sl.replace(i,str_b.size(),str_a,0,str_a.size());
                if(ump2[sl]==0)
                {
                    ump2[sl]=ump2[s]+1;
                    que.push(sl);
                }
            }
        }
    }

}


int main(){
ll i,j;

cin>>beg>>ed;

while(cin>>str_a>>str_b)
{
    ve.push_back({str_a,str_b});
}

if(beg==ed)
{
    printf("0\n");
    return 0;
}

bfs1();

if(ans==15) bfs2();

if(ans<=10)
    printf("%lld\n",ans);
else
    printf("NO ANSWER!\n");

}
```





## A*



### 第K短路
给定一张 $N$ 个点（编号 $1,2\cdots N$），$M$ 条边的有向图，求从起点 $S$ 到终点 $T$ 的第 $K$ 短路的长度，路径允许重复经过点或边。
注意： 每条最短路中至少要包含一条边。

输入格式
第一行包含两个整数 $N$ 和 $M$。
接下来 $M$ 行，每行包含三个整数 $A,B$ 和 $L$，表示点 $A$ 与点 $B$ 之间存在有向边，且边长为 $L$。
最后一行包含三个整数 $S,T$ 和 $K$，分别表示起点 $S$，终点 $T$ 和第 $K$ 短路。

输出格式
输出占一行，包含一个整数，表示第 $K$ 短路的长度，如果第 $K$ 短路不存在，则输出 $-1$。

数据范围
$1 \le S,T \le N \le 1000$,
$0 \le M \le 10^5$,
$1 \le K \le 1000$,
$1 \le L \le 100$

输入样例：
2 2
1 2 5
2 1 4
1 2 2

输出样例：
14

> A* 本质上是对广搜进行一种优化。使得优先查找最优情况。
>
> 在这题，先dijkstra得到每个点到终点的最短路，作为A*的估价函数
>
> A*的估价函数是该点从起点的距离（真实值）+到终点的距离（上面得到的最短路值）。估价函数为估计值。
>
> 将A*的估价函数，当前点，当前点到起点的距离存进优先队列，优先队列对估价函数按升序排序。第k个弹出的终点的结果即为最后的答案
>
> 此处还要对查找进行剪枝。如果某个中间点弹出次数大于$K$，没必要继续再更新该点。

```c++
#include <bits/stdc++.h>
typedef int ll;
const ll maxn=1e5+5;
using namespace std;

typedef pair<ll,ll> PII;
typedef pair<ll,pair<ll,ll> > PIII;

ll h[maxn];ll rh[maxn];ll ne[maxn<<1];ll e[maxn<<1];ll v[maxn<<1];ll idx;
ll n,m;ll beg,ed;ll k;
ll dist[maxn];
ll cnt[maxn];

void Add(ll h[],ll a,ll b,ll c)
{
    idx++;
    e[idx]=b;
    v[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}

void Dijkstra()
{
    memset(dist,-1,sizeof dist);

    priority_queue<PII,vector<PII>,greater<PII> >que;
    que.push({0,ed});
    
    while(!que.empty())
    {
        ll x=que.top().second;ll dis=que.top().first;
        que.pop();
        
        if(dist[x]!=-1)  continue;
        
        dist[x]=dis;
        
        for(ll i=rh[x];i!=0;i=ne[i])
        {
            ll j=e[i];ll c=v[i];
            if(dist[j]==-1)
            {
                que.push({dis+c,j});
            }
        }
    }
}

ll astar()
{
    ll i,j;
    priority_queue<PIII,vector<PIII>,greater<PIII> > que;
    
    que.push({dist[beg],{0,beg}});
    
    while(!que.empty())
    {
        ll dis=que.top().second.first;ll x=que.top().second.second;
        que.pop();
        
        cnt[x]++;
        
        if(cnt[ed]==k)  return dis;
        
        for(ll i=h[x];i!=0;i=ne[i])
        {
            ll j=e[i];ll c=v[i];
            if(cnt[j]<k)
            {
                que.push({dis+c+dist[j],{dis+c,j}});
            }
        }
    }
    return -1;
}

int main(){
ll i,j;
ll a,b,c;

cin>>n>>m;

for(i=1;i<=m;i++)
{
    scanf("%d%d%d",&a,&b,&c);
    Add(h,a,b,c);
    Add(rh,b,a,c);
}

cin>>beg>>ed>>k;   

if(beg==ed) k++;

Dijkstra();

printf("%d\n",astar());
   
}
```





# —————————————
